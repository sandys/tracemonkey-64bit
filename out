# 1 "./nanojit/NativeAMD64.cpp"
# 1 "/home/user/stuff/tmp2/src3//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "././config/gcc_hidden.h" 1

#pragma GCC visibility push(hidden)
# 1 "<command-line>" 2
# 1 "././mozilla-config.h" 1
# 1 "<command-line>" 2
# 1 "./nanojit/NativeAMD64.cpp"
# 40 "./nanojit/NativeAMD64.cpp"
# 1 "./nanojit/nanojit.h" 1
# 42 "./nanojit/nanojit.h"
# 1 "./dist/include/system_wrappers_js/stddef.h" 1
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 152 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 214 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 43 "./nanojit/nanojit.h" 2
# 1 "./nanojit/avmplus.h" 1
# 37 "./nanojit/avmplus.h"
# 1 "./dist/include/system_wrappers_js/assert.h" 1
       
# 2 "./dist/include/system_wrappers_js/assert.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/assert.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/features.h" 1 3 4
# 330 "/usr/include/features.h" 3 4
# 1 "./dist/include/system_wrappers_js/sys/cdefs.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/sys/cdefs.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 348 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 349 "/usr/include/sys/cdefs.h" 2 3 4
# 4 "./dist/include/system_wrappers_js/sys/cdefs.h" 2 3
#pragma GCC visibility pop
# 331 "/usr/include/features.h" 2 3 4
# 354 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4




# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 2 3 4
# 355 "/usr/include/features.h" 2 3 4
# 4 "./dist/include/system_wrappers_js/features.h" 2 3
#pragma GCC visibility pop
# 38 "/usr/include/assert.h" 2 3 4
# 68 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 4 "./dist/include/system_wrappers_js/assert.h" 2 3
#pragma GCC visibility pop
# 38 "./nanojit/avmplus.h" 2
# 1 "./dist/include/system_wrappers_js/string.h" 1
       
# 2 "./dist/include/system_wrappers_js/string.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "./dist/include/system_wrappers_js/stddef.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern void *rawmemchr (__const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;
# 119 "/usr/include/string.h" 2 3 4


extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 165 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strrchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strchrnul (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strpbrk (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strstr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));




extern char *strcasestr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 281 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));






extern char *basename (__const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
# 428 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/string3.h" 1 3 4
# 23 "/usr/include/bits/string3.h" 3 4
extern void __warn_memset_zero_len (void) __attribute__((__warning__ ("memset used with constant zero length parameter; this could be due to transposed parameters")));
# 48 "/usr/include/bits/string3.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len) throw ()

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memmove (void *__restrict __dest, __const void *__restrict __src, size_t __len) throw ()

{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
mempcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len) throw ()

{
  return __builtin___mempcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 77 "/usr/include/bits/string3.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
memset (void *__dest, int __ch, size_t __len) throw ()
{
  if (__builtin_constant_p (__len) && __len == 0)
    {
      __warn_memset_zero_len ();
      return __dest;
    }
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void
bcopy (__const void *__restrict __src, void *__restrict __dest, size_t __len) throw ()

{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void
bzero (void *__dest, size_t __len) throw ()
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strcpy (char *__restrict __dest, __const char *__restrict __src) throw ()
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
stpcpy (char *__restrict __dest, __const char *__restrict __src) throw ()
{
  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strncpy (char *__restrict __dest, __const char *__restrict __src, size_t __len) throw ()

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}


extern char *__stpncpy_chk (char *__dest, __const char *__src, size_t __n,
       size_t __destlen) throw ();
extern char *__stpncpy_alias (char *__dest, __const char *__src, size_t __n) throw () __asm__ ("" "stpncpy");



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
stpncpy (char *__dest, __const char *__src, size_t __n) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n <= __builtin_object_size (__dest, 2 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strcat (char *__restrict __dest, __const char *__restrict __src) throw ()
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
strncat (char *__restrict __dest, __const char *__restrict __src, size_t __len) throw ()

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
# 429 "/usr/include/string.h" 2 3 4



}
# 4 "./dist/include/system_wrappers_js/string.h" 2 3
#pragma GCC visibility pop
# 39 "./nanojit/avmplus.h" 2
# 1 "./dist/include/system_wrappers_js/stdio.h" 1
       
# 2 "./dist/include/system_wrappers_js/stdio.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 29 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "./dist/include/system_wrappers_js/stddef.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 28 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "./dist/include/system_wrappers_js/stddef.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "./dist/include/system_wrappers_js/wchar.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/wchar.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/wchar.h" 1 3 4
# 78 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 4 "./dist/include/system_wrappers_js/wchar.h" 2 3
#pragma GCC visibility pop
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "./dist/include/system_wrappers_js/stdarg.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stdarg.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 4 "./dist/include/system_wrappers_js/stdarg.h" 2 3
#pragma GCC visibility pop
# 54 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 458 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 488 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 550 "/usr/include/libio.h" 3 4
}
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 89 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 141 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 142 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();








extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
# 182 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) __attribute__ ((__warn_unused_result__));



extern char *tmpnam (char *__s) throw () __attribute__ ((__warn_unused_result__));





extern char *tmpnam_r (char *__s) throw () __attribute__ ((__warn_unused_result__));
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 229 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 272 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern FILE *fdopen (int __fd, __const char *__modes) throw () __attribute__ ((__warn_unused_result__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () __attribute__ ((__warn_unused_result__));


extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () __attribute__ ((__warn_unused_result__));






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));







extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (__const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 441 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 500 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 528 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 539 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 572 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));






extern char *gets (char *__s) __attribute__ ((__warn_unused_result__));

# 618 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 634 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 695 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 706 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);

# 742 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
# 761 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 784 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 823 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));
# 842 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) throw ();
# 906 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio2.h" 1 3 4
# 24 "/usr/include/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     __const char *__restrict __format, ...) throw ();
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      __const char *__restrict __format,
      __gnuc_va_list __ap) throw ();


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
sprintf (char *__restrict __s, __const char *__restrict __fmt, ...) throw ()
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vsprintf (char *__restrict __s, __const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, __const char *__restrict __format,
      ...) throw ();
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, __const char *__restrict __format,
       __gnuc_va_list __ap) throw ();


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
snprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, ...) throw ()

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vsnprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     __const char *__restrict __format, ...);
extern int __printf_chk (int __flag, __const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      __const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, __const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __ap)
{



  return __vprintf_chk (2 - 1, __fmt, __ap);

}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vfprintf (FILE *__restrict __stream,
   __const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}



extern int __asprintf_chk (char **__restrict __ptr, int __flag,
      __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__warn_unused_result__));
extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
       __const char *__restrict __fmt, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0))) __attribute__ ((__warn_unused_result__));
extern int __dprintf_chk (int __fd, int __flag, __const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      __const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));
extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
     int __flag, __const char *__restrict __format,
     ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
      int __flag,
      __const char *__restrict __format,
      __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...) throw ()
{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
__asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...) throw ()

{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
dprintf (int __fd, __const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
obstack_printf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, ...) throw ()

{
  return __obstack_printf_chk (__obstack, 2 - 1, __fmt,
          __builtin_va_arg_pack ());
}
# 195 "/usr/include/bits/stdio2.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vasprintf (char **__restrict __ptr, __const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __vasprintf_chk (__ptr, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
vdprintf (int __fd, __const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
obstack_vprintf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __obstack_vprintf_chk (__obstack, 2 - 1, __fmt,
    __ap);
}





extern char *__gets_chk (char *__str, size_t) __attribute__ ((__warn_unused_result__));
extern char *__gets_warn (char *__str) __asm__ ("" "gets")
     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use fgets or getline instead, gets can't " "specify buffer size")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
gets (char *__str)
{
  if (__builtin_object_size (__str, 2 > 1) != (size_t) -1)
    return __gets_chk (__str, __builtin_object_size (__str, 2 > 1));
  return __gets_warn (__str);
}

extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets") __attribute__ ((__warn_unused_result__));


extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread") __attribute__ ((__warn_unused_result__));



extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}


extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
       int __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked") __attribute__ ((__warn_unused_result__));


extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_unlocked_alias (__s, __n, __stream);
}




extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked") __attribute__ ((__warn_unused_result__));



extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
         __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
       __stream);
    }
# 372 "/usr/include/bits/stdio2.h" 3 4
  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}
# 907 "/usr/include/stdio.h" 2 3 4





}
# 4 "./dist/include/system_wrappers_js/stdio.h" 2 3
#pragma GCC visibility pop
# 40 "./nanojit/avmplus.h" 2
# 1 "./dist/include/system_wrappers_js/stdlib.h" 1
       
# 2 "./dist/include/system_wrappers_js/stdlib.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 26 "/usr/include/stdlib.h" 2 3 4







# 1 "./dist/include/system_wrappers_js/stddef.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 65 "/usr/include/bits/waitstatus.h" 3 4
# 1 "./dist/include/system_wrappers_js/endian.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/endian.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/endian.h" 1 3 4
# 22 "/usr/include/endian.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 23 "/usr/include/endian.h" 2 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 4 "./dist/include/system_wrappers_js/endian.h" 2 3
#pragma GCC visibility pop
# 66 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () __attribute__ ((__warn_unused_result__));




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));
# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () __attribute__ ((__warn_unused_result__));


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




# 1 "./dist/include/system_wrappers_js/sys/types.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/sys/types.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 28 "/usr/include/sys/types.h" 2 3 4

extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;




typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "./dist/include/system_wrappers_js/time.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/time.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/time.h" 1 3 4
# 59 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 75 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 93 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 105 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 4 "./dist/include/system_wrappers_js/time.h" 2 3
#pragma GCC visibility pop
# 134 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "./dist/include/system_wrappers_js/stddef.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 217 "/usr/include/sys/types.h" 3 4
# 1 "./dist/include/system_wrappers_js/endian.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/endian.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 218 "/usr/include/sys/types.h" 2 3 4


# 1 "./dist/include/system_wrappers_js/sys/select.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/sys/select.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/select.h" 1 3 4
# 25 "/usr/include/sys/select.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 26 "/usr/include/sys/select.h" 2 3 4





# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "./dist/include/system_wrappers_js/time.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/time.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/time.h" 1 3 4
# 121 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 4 "./dist/include/system_wrappers_js/time.h" 2 3
#pragma GCC visibility pop
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 4 "./dist/include/system_wrappers_js/sys/select.h" 2 3
#pragma GCC visibility pop
# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/sys/sysmacros.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 25 "/usr/include/sys/sysmacros.h" 2 3 4





__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();
# 224 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 76 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 101 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
# 187 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4


}
# 4 "./dist/include/system_wrappers_js/sys/types.h" 2 3
#pragma GCC visibility pop
# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "./dist/include/system_wrappers_js/alloca.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/alloca.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/alloca.h" 1 3 4
# 22 "/usr/include/alloca.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 23 "/usr/include/alloca.h" 2 3 4


# 1 "./dist/include/system_wrappers_js/stddef.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 4 "./dist/include/system_wrappers_js/alloca.h" 2 3
#pragma GCC visibility pop
# 498 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));






extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw ();






extern int clearenv (void) throw ();
# 583 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 594 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 604 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 614 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 625 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 635 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));









extern int system (__const char *__command) __attribute__ ((__warn_unused_result__));






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 662 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));

# 735 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () __attribute__ ((__warn_unused_result__));


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () __attribute__ ((__warn_unused_result__));


extern int wctomb (char *__s, wchar_t __wchar) throw () __attribute__ ((__warn_unused_result__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 823 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () __attribute__ ((__warn_unused_result__));






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));





# 1 "/usr/include/bits/stdlib.h" 1 3 4
# 24 "/usr/include/bits/stdlib.h" 3 4
extern char *__realpath_chk (__const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) throw () __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (__const char *__restrict __name, char *__restrict __resolved) throw () __asm__ ("" "realpath") __attribute__ ((__warn_unused_result__));


extern char *__realpath_chk_warn (__const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) throw () __asm__ ("" "__realpath_chk") __attribute__ ((__warn_unused_result__))



     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
realpath (__const char *__restrict __name, char *__restrict __resolved) throw ()
{
  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
    {




      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) throw () __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) throw () __asm__ ("" "ptsname_r")

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__ptsname_r_chk")


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
ptsname_r (int __fd, char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  throw () __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) throw () __asm__ ("" "wctomb") __attribute__ ((__warn_unused_result__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) int
wctomb (char *__s, wchar_t __wchar) throw ()
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         __const char *__restrict __src,
         size_t __len, size_t __dstlen) throw ();
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len) throw () __asm__ ("" "mbstowcs");



extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len, size_t __dstlen) throw () __asm__ ("" "__mbstowcs_chk")



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
mbstowcs (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         __const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) throw ();
extern size_t __wcstombs_alias (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len) throw () __asm__ ("" "wcstombs");



extern size_t __wcstombs_chk_warn (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len, size_t __dstlen) throw () __asm__ ("" "__wcstombs_chk")



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
wcstombs (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 883 "/usr/include/stdlib.h" 2 3 4
# 891 "/usr/include/stdlib.h" 3 4
}
# 4 "./dist/include/system_wrappers_js/stdlib.h" 2 3
#pragma GCC visibility pop
# 41 "./nanojit/avmplus.h" 2


# 1 "./dist/include/system_wrappers_js/unistd.h" 1
       
# 2 "./dist/include/system_wrappers_js/unistd.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/unistd.h" 1 3 4
# 26 "/usr/include/unistd.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/unistd.h" 2 3 4

extern "C" {
# 173 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 174 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 178 "/usr/include/unistd.h" 2 3 4
# 197 "/usr/include/unistd.h" 3 4
# 1 "./dist/include/system_wrappers_js/stddef.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 198 "/usr/include/unistd.h" 2 3 4
# 238 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 258 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));
# 301 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 312 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __attribute__ ((__warn_unused_result__));





extern ssize_t write (int __fd, __const void *__buf, size_t __n) __attribute__ ((__warn_unused_result__));
# 343 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) __attribute__ ((__warn_unused_result__));






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) __attribute__ ((__warn_unused_result__));
# 371 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) __attribute__ ((__warn_unused_result__));


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) __attribute__ ((__warn_unused_result__));







extern int pipe (int __pipedes[2]) throw () __attribute__ ((__warn_unused_result__));




extern int pipe2 (int __pipedes[2], int __flags) throw () __attribute__ ((__warn_unused_result__));
# 399 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 411 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 435 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () __attribute__ ((__warn_unused_result__));




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchdir (int __fd) throw () __attribute__ ((__warn_unused_result__));
# 477 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () __attribute__ ((__warn_unused_result__));





extern char *get_current_dir_name (void) throw ();






extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__));




extern int dup (int __fd) throw () __attribute__ ((__warn_unused_result__));


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw ();




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));




extern int nice (int __inc) throw () __attribute__ ((__warn_unused_result__));




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
# 567 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 603 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 629 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 646 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () __attribute__ ((__warn_unused_result__));



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();






extern __pid_t fork (void) throw ();






extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) __attribute__ ((__warn_unused_result__));




extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 849 "/usr/include/unistd.h" 3 4
# 1 "./dist/include/system_wrappers_js/getopt.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/getopt.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/getopt.h" 1 3 4
# 50 "/usr/include/getopt.h" 3 4
extern "C" {
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 171 "/usr/include/getopt.h" 3 4
}
# 4 "./dist/include/system_wrappers_js/getopt.h" 2 3
#pragma GCC visibility pop
# 850 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int sethostid (long int __id) throw () __attribute__ ((__warn_unused_result__));





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () __attribute__ ((__warn_unused_result__));






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 935 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();




extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();




extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 972 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 982 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () __attribute__ ((__warn_unused_result__));
# 992 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () __attribute__ ((__warn_unused_result__));
# 1002 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () __attribute__ ((__warn_unused_result__));





extern void *sbrk (intptr_t __delta) throw ();
# 1023 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1046 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) __attribute__ ((__warn_unused_result__));
# 1056 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) __attribute__ ((__warn_unused_result__));
# 1077 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();





# 1 "/usr/include/bits/unistd.h" 1 3 4
# 24 "/usr/include/bits/unistd.h" 3 4
extern ssize_t __read_chk (int __fd, void *__buf, size_t __nbytes,
      size_t __buflen) __attribute__ ((__warn_unused_result__));
extern ssize_t __read_alias (int __fd, void *__buf, size_t __nbytes) __asm__ ("" "read") __attribute__ ((__warn_unused_result__));

extern ssize_t __read_chk_warn (int __fd, void *__buf, size_t __nbytes, size_t __buflen) __asm__ ("" "__read_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("read called with bigger length than size of " "the destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __read_chk (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));

      if (__nbytes > __builtin_object_size (__buf, 0))
 return __read_chk_warn (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));
    }
  return __read_alias (__fd, __buf, __nbytes);
}


extern ssize_t __pread_chk (int __fd, void *__buf, size_t __nbytes,
       __off_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread64_chk (int __fd, void *__buf, size_t __nbytes,
         __off64_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread_alias (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __asm__ ("" "pread") __attribute__ ((__warn_unused_result__));


extern ssize_t __pread64_alias (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") __attribute__ ((__warn_unused_result__));


extern ssize_t __pread_chk_warn (int __fd, void *__buf, size_t __nbytes, __off_t __offset, size_t __bufsize) __asm__ ("" "__pread_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread called with bigger length than size of " "the destination buffer")));

extern ssize_t __pread64_chk_warn (int __fd, void *__buf, size_t __nbytes, __off64_t __offset, size_t __bufsize) __asm__ ("" "__pread64_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread64 called with bigger length than size of " "the destination buffer")));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread_chk_warn (__fd, __buf, __nbytes, __offset,
     __builtin_object_size (__buf, 0));
    }
  return __pread_alias (__fd, __buf, __nbytes, __offset);
}
# 105 "/usr/include/bits/unistd.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread64 (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread64_chk_warn (__fd, __buf, __nbytes, __offset,
       __builtin_object_size (__buf, 0));
    }

  return __pread64_alias (__fd, __buf, __nbytes, __offset);
}




extern ssize_t __readlink_chk (__const char *__restrict __path,
          char *__restrict __buf, size_t __len,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_alias (__const char *__restrict __path, char *__restrict __buf, size_t __len) throw () __asm__ ("" "readlink")


     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_chk_warn (__const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__readlink_chk")



     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlink called with bigger length " "than size of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) ssize_t
readlink (__const char *__restrict __path, char *__restrict __buf, size_t __len) throw ()

{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlink_chk (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if ( __len > __builtin_object_size (__buf, 2 > 1))
 return __readlink_chk_warn (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1));
    }
  return __readlink_alias (__path, __buf, __len);
}



extern ssize_t __readlinkat_chk (int __fd, __const char *__restrict __path,
     char *__restrict __buf, size_t __len,
     size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_alias (int __fd, __const char *__restrict __path, char *__restrict __buf, size_t __len) throw () __asm__ ("" "readlinkat")



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_chk_warn (int __fd, __const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__readlinkat_chk")



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlinkat called with bigger " "length than size of destination " "buffer")));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) ssize_t
readlinkat (int __fd, __const char *__restrict __path, char *__restrict __buf, size_t __len) throw ()

{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlinkat_chk (__fd, __path, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if (__len > __builtin_object_size (__buf, 2 > 1))
 return __readlinkat_chk_warn (__fd, __path, __buf, __len,
          __builtin_object_size (__buf, 2 > 1));
    }
  return __readlinkat_alias (__fd, __path, __buf, __len);
}


extern char *__getcwd_chk (char *__buf, size_t __size, size_t __buflen)
     throw () __attribute__ ((__warn_unused_result__));
extern char *__getcwd_alias (char *__buf, size_t __size) throw () __asm__ ("" "getcwd") __attribute__ ((__warn_unused_result__));

extern char *__getcwd_chk_warn (char *__buf, size_t __size, size_t __buflen) throw () __asm__ ("" "__getcwd_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getcwd caller with bigger length than size of " "destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__warn_unused_result__)) char *
getcwd (char *__buf, size_t __size) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size))
 return __getcwd_chk (__buf, __size, __builtin_object_size (__buf, 2 > 1));

      if (__size > __builtin_object_size (__buf, 2 > 1))
 return __getcwd_chk_warn (__buf, __size, __builtin_object_size (__buf, 2 > 1));
    }
  return __getcwd_alias (__buf, __size);
}


extern char *__getwd_chk (char *__buf, size_t buflen)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern char *__getwd_warn (char *__buf) throw () __asm__ ("" "getwd")
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use getcwd instead, as getwd " "doesn't specify buffer size")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__)) char *
getwd (char *__buf) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    return __getwd_chk (__buf, __builtin_object_size (__buf, 2 > 1));
  return __getwd_warn (__buf);
}


extern size_t __confstr_chk (int __name, char *__buf, size_t __len,
        size_t __buflen) throw ();
extern size_t __confstr_alias (int __name, char *__buf, size_t __len) throw () __asm__ ("" "confstr");

extern size_t __confstr_chk_warn (int __name, char *__buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__confstr_chk")


     __attribute__((__warning__ ("confstr called with bigger length than size of destination " "buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) size_t
confstr (int __name, char *__buf, size_t __len) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __confstr_chk (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if (__builtin_object_size (__buf, 2 > 1) < __len)
 return __confstr_chk_warn (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1));
    }
  return __confstr_alias (__name, __buf, __len);
}


extern int __getgroups_chk (int __size, __gid_t __list[], size_t __listlen)
     throw () __attribute__ ((__warn_unused_result__));
extern int __getgroups_alias (int __size, __gid_t __list[]) throw () __asm__ ("" "getgroups") __attribute__ ((__warn_unused_result__));

extern int __getgroups_chk_warn (int __size, __gid_t __list[], size_t __listlen) throw () __asm__ ("" "__getgroups_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getgroups called with bigger group count than what " "can fit into destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
getgroups (int __size, __gid_t __list[]) throw ()
{
  if (__builtin_object_size (__list, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size) || __size < 0)
 return __getgroups_chk (__size, __list, __builtin_object_size (__list, 2 > 1));

      if (__size * sizeof (__gid_t) > __builtin_object_size (__list, 2 > 1))
 return __getgroups_chk_warn (__size, __list, __builtin_object_size (__list, 2 > 1));
    }
  return __getgroups_alias (__size, __list);
}


extern int __ttyname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) throw () __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_alias (int __fd, char *__buf, size_t __buflen) throw () __asm__ ("" "ttyname_r")

     __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__ttyname_r_chk")


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ttyname_r called with bigger buflen than " "size of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
ttyname_r (int __fd, char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ttyname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ttyname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ttyname_r_alias (__fd, __buf, __buflen);
}



extern int __getlogin_r_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_alias (char *__buf, size_t __buflen) __asm__ ("" "getlogin_r") __attribute__ ((__nonnull__ (1)));

extern int __getlogin_r_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getlogin_r_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("getlogin_r called with bigger buflen than " "size of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
getlogin_r (char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getlogin_r_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __getlogin_r_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __getlogin_r_alias (__buf, __buflen);
}




extern int __gethostname_chk (char *__buf, size_t __buflen, size_t __nreal)
     throw () __attribute__ ((__nonnull__ (1)));
extern int __gethostname_alias (char *__buf, size_t __buflen) throw () __asm__ ("" "gethostname") __attribute__ ((__nonnull__ (1)));

extern int __gethostname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__gethostname_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("gethostname called with bigger buflen than " "size of destination buffer")));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
gethostname (char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __gethostname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __gethostname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __gethostname_alias (__buf, __buflen);
}




extern int __getdomainname_chk (char *__buf, size_t __buflen, size_t __nreal)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int __getdomainname_alias (char *__buf, size_t __buflen) throw () __asm__ ("" "getdomainname") __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));


extern int __getdomainname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__getdomainname_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getdomainname called with bigger " "buflen than size of destination " "buffer")));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) int
getdomainname (char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getdomainname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __getdomainname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __getdomainname_alias (__buf, __buflen);
}
# 1113 "/usr/include/unistd.h" 2 3 4


}
# 4 "./dist/include/system_wrappers_js/unistd.h" 2 3
#pragma GCC visibility pop
# 44 "./nanojit/avmplus.h" 2
# 1 "./dist/include/system_wrappers_js/sys/mman.h" 1
       
# 2 "./dist/include/system_wrappers_js/sys/mman.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/sys/mman.h" 1 3 4
# 23 "/usr/include/sys/mman.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 24 "/usr/include/sys/mman.h" 2 3 4


# 1 "./dist/include/system_wrappers_js/stddef.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 27 "/usr/include/sys/mman.h" 2 3 4
# 42 "/usr/include/sys/mman.h" 3 4
# 1 "/usr/include/bits/mman.h" 1 3 4
# 43 "/usr/include/sys/mman.h" 2 3 4




extern "C" {
# 58 "/usr/include/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) throw ();
# 71 "/usr/include/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) throw ();




extern int munmap (void *__addr, size_t __len) throw ();




extern int mprotect (void *__addr, size_t __len, int __prot) throw ();







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) throw ();



extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();




extern int mlock (__const void *__addr, size_t __len) throw ();


extern int munlock (__const void *__addr, size_t __len) throw ();




extern int mlockall (int __flags) throw ();



extern int munlockall (void) throw ();







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     throw ();
# 134 "/usr/include/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) throw ();



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) throw ();




extern int shm_open (__const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (__const char *__name);

}
# 4 "./dist/include/system_wrappers_js/sys/mman.h" 2 3
#pragma GCC visibility pop
# 45 "./nanojit/avmplus.h" 2


# 1 "./jstypes.h" 1
# 57 "./jstypes.h"
# 1 "./dist/include/system_wrappers_js/stddef.h" 1
       
# 2 "./dist/include/system_wrappers_js/stddef.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stddef.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stddef.h" 2 3
#pragma GCC visibility pop
# 58 "./jstypes.h" 2
# 1 "./jsstdint.h" 1
# 46 "./jsstdint.h"
# 1 "./js-config.h" 1
# 47 "./jsstdint.h" 2



# 1 "./dist/include/system_wrappers_js/stdint.h" 1
       
# 2 "./dist/include/system_wrappers_js/stdint.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 66 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 91 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 104 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 123 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 135 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 4 "./dist/include/system_wrappers_js/stdint.h" 2 3
#pragma GCC visibility pop
# 51 "./jsstdint.h" 2
# 59 "./jstypes.h" 2
# 279 "./jstypes.h"
# 1 "./jsautocfg.h" 1
# 280 "./jstypes.h" 2


extern "C" {
# 292 "./jstypes.h"
typedef uint8_t JSUint8;
typedef int8_t JSInt8;
# 302 "./jstypes.h"
typedef uint16_t JSUint16;
typedef int16_t JSInt16;
# 312 "./jstypes.h"
typedef uint32_t JSUint32;
typedef int32_t JSInt32;
# 326 "./jstypes.h"
typedef uint64_t JSUint64;
typedef int64_t JSInt64;
# 339 "./jstypes.h"
typedef int JSIntn;
typedef unsigned int JSUintn;






typedef double JSFloat64;






typedef size_t JSSize;







typedef ptrdiff_t JSPtrdiff;







typedef uintptr_t JSUptrdiff;
# 380 "./jstypes.h"
typedef JSIntn JSBool;
# 390 "./jstypes.h"
typedef JSUint8 JSPackedBool;




typedef intptr_t JSWord;
typedef uintptr_t JSUword;

# 1 "./jsotypes.h" 1
# 71 "./jsotypes.h"
# 1 "./dist/include/system_wrappers_js/sys/types.h" 1
       
# 2 "./dist/include/system_wrappers_js/sys/types.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 72 "./jsotypes.h" 2




typedef JSUintn uintn;
typedef JSUint64 uint64;

typedef JSUint32 uint32;



typedef JSUint16 uint16;
typedef JSUint8 uint8;


typedef JSIntn intn;
# 99 "./jsotypes.h"
typedef JSInt64 int64;






typedef JSInt32 int32;



typedef JSInt16 int16;
typedef JSInt8 int8;





typedef JSFloat64 float64;
# 399 "./jstypes.h" 2
# 479 "./jstypes.h"
}
# 48 "./nanojit/avmplus.h" 2
# 82 "./nanojit/avmplus.h"
# 1 "./dist/include/system_wrappers_js/stdarg.h" 1
       
# 2 "./dist/include/system_wrappers_js/stdarg.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.3.3/include/stdarg.h" 1 3 4
# 4 "./dist/include/system_wrappers_js/stdarg.h" 2 3
#pragma GCC visibility pop
# 83 "./nanojit/avmplus.h" 2



void NanoAssertFail();
# 121 "./nanojit/avmplus.h"
static __inline__ uint64_t rdtsc(void)
{
  unsigned hi, lo;
  __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
  return ( (uint64_t)lo)|( ((uint64_t)hi)<<32 );
}
# 154 "./nanojit/avmplus.h"
struct JSContext;

namespace avmplus {

    class GC;

    class GCObject
    {
    public:
        inline void*
        operator new(size_t size, GC* gc)
        {
            return calloc(1, size);
        }

        static void operator delete (void *gcObject)
        {
            free(gcObject);
        }
    };



    class GCFinalizedObject : public GCObject
    {
    public:
        static void operator delete (void *gcObject)
        {
            free(gcObject);
        }
    };

    class GCHeap
    {
    public:
        int32_t kNativePageSize;

        GCHeap()
        {

            kNativePageSize = sysconf(_SC_PAGESIZE);



        }

        inline void*
        Alloc(uint32_t pages)
        {
# 213 "./nanojit/avmplus.h"
            return mmap(__null,
                        pages * kNativePageSize,
                        0x1 | 0x2 | 0x4,
                        0x02 | 0x20,
                        -1,
                        0);



        }

        inline void
        Free(void* p, uint32_t pages)
        {






            munmap(p, pages * kNativePageSize);




        }

    };

    class GC
    {
        static GCHeap heap;

    public:



  enum AllocFlags
  {
   kZero=1,
   kContainsPointers=2,
   kFinalize=4,
   kRCObject=8
  };

        static inline void*
        Alloc(uint32_t bytes, int flags=kZero)
        {
          if (flags & kZero)
            return calloc(1, bytes);
          else
            return malloc(bytes);
        }

        static inline void
        Free(void* p)
        {
            free(p);
        }

        static inline GCHeap*
        GetGCHeap()
        {
            return &heap;
        }
    };
# 287 "./nanojit/avmplus.h"
    typedef int FunctionID;

    class String
    {
    };

    typedef class String AvmString;

    class StringNullTerminatedUTF8
    {
        const char* cstr;

    public:
        StringNullTerminatedUTF8(GC* gc, String* s)
        {
            cstr = strdup((const char*)s);
        }

        ~StringNullTerminatedUTF8()
        {
            free((void*)cstr);
        }

        inline
        const char* c_str()
        {
            return cstr;
        }
    };

    typedef String* Stringp;

    class Config
    {
    public:
        Config() {
            memset(this, 0, sizeof(Config));

            verbose = getenv("TRACEMONKEY") && strstr(getenv("TRACEMONKEY"), "verbose");
            verbose_addrs = 1;
            verbose_exits = 1;
            verbose_live = 1;
            show_stats = 1;

        }

        uint32_t tree_opt:1;
        uint32_t quiet_opt:1;
        uint32_t verbose:1;
        uint32_t verbose_addrs:1;
        uint32_t verbose_live:1;
        uint32_t verbose_exits:1;
        uint32_t show_stats:1;
# 366 "./nanojit/avmplus.h"
        bool soft_float;

    };

    static const int kstrconst_emptyString = 0;

    class AvmInterpreter
    {
        class Labels {
        public:
            const char* format(const void* ip)
            {
                static char buf[33];
                sprintf(buf, "%p", ip);
                return buf;
            }
        };

        Labels _labels;
    public:
        Labels* labels;

        AvmInterpreter()
        {
            labels = &_labels;
        }

    };

    class AvmConsole
    {
    public:
        AvmConsole& operator<<(const char* s)
        {
            fprintf(stdout, "%s", s);
            return *this;
        }
    };

    class AvmCore
    {
    public:
        AvmInterpreter interp;
        AvmConsole console;

        static Config config;
        static GC* gc;
        static String* k_str[];
# 423 "./nanojit/avmplus.h"
        static inline bool
        use_cmov()
        {



     return true;

        }

        static inline bool
        quiet_opt()
        {
            return config.quiet_opt;
        }

        static inline bool
        verbose()
        {
            return config.verbose;
        }

        static inline GC*
        GetGC()
        {
            return gc;
        }

        static inline String* newString(const char* cstr) {
            return (String*)strdup(cstr);
        }

        static inline void freeString(String* str) {
            return free((char*)str);
        }
    };

    class OSDep
    {
    public:
        static inline void
        getDate()
        {
        }
    };
# 483 "./nanojit/avmplus.h"
    enum ListElementType {
        LIST_NonGCObjects = 0,
        LIST_GCObjects = 1,
        LIST_RCObjects = 2
    };

    template <typename T, ListElementType kElementType>
    class List
    {
    public:
        enum { kInitialCapacity = 128 };

        List(GC *_gc, uint32_t _capacity=kInitialCapacity) : data(__null), len(0), capacity(0)
        {
            ensureCapacity(_capacity);
        }

        ~List()
        {

            destroy();

            len = 0;
        }

        inline void destroy()
        {
            if (data)
                free(data);
        }

        const T *getData() const { return data; }


        void become(List& that)
        {
            this->destroy();

            this->data = that.data;
            this->len = that.len;
     this->capacity = that.capacity;

            that.data = 0;
            that.len = 0;
     that.capacity = 0;
        }
        uint32_t add(T value)
        {
            if (len >= capacity) {
                grow();
            }
            wb(len++, value);
            return len-1;
        }

        inline bool isEmpty() const
        {
            return len == 0;
        }

        inline uint32_t size() const
        {
            return len;
        }

        inline T get(uint32_t index) const
        {
            ((index < len) ? static_cast<void> (0) : __assert_fail ("index < len", "./nanojit/avmplus.h", 550, __PRETTY_FUNCTION__));
            return *(T*)(data + index);
        }

        void set(uint32_t index, T value)
        {
            ((index < capacity) ? static_cast<void> (0) : __assert_fail ("index < capacity", "./nanojit/avmplus.h", 556, __PRETTY_FUNCTION__));
            if (index >= len)
            {
                len = index+1;
            }
            ((len <= capacity) ? static_cast<void> (0) : __assert_fail ("len <= capacity", "./nanojit/avmplus.h", 561, __PRETTY_FUNCTION__));
            wb(index, value);
        }

        void add(const List<T, kElementType>& l)
        {
            ensureCapacity(len+l.size());

            ((kElementType != LIST_RCObjects) ? static_cast<void> (0) : __assert_fail ("kElementType != LIST_RCObjects", "./nanojit/avmplus.h", 569, __PRETTY_FUNCTION__));
            arraycopy(l.getData(), 0, data, len, l.size());
            len += l.size();
        }

        inline void clear()
        {
            zero_range(0, len);
            len = 0;
        }

        int indexOf(T value) const
        {
            for(uint32_t i=0; i<len; i++)
                if (get(i) == value)
                    return i;
            return -1;
        }

        int lastIndexOf(T value) const
        {
            for(int32_t i=len-1; i>=0; i--)
                if (get(i) == value)
                    return i;
            return -1;
        }

        inline T last() const
        {
            return get(len-1);
        }

        T removeLast()
        {
            if(isEmpty())
                return undef_list_val();
            T t = get(len-1);
            set(len-1, undef_list_val());
            len--;
            return t;
        }

        inline T operator[](uint32_t index) const
        {
            ((index < capacity) ? static_cast<void> (0) : __assert_fail ("index < capacity", "./nanojit/avmplus.h", 613, __PRETTY_FUNCTION__));
            return get(index);
        }

        void ensureCapacity(uint32_t cap)
        {
            if (cap > capacity) {
                if (data == __null) {
                    data = (T*)calloc(1, factor(cap));
                } else {
                    data = (T*)realloc(data, factor(cap));
                    zero_range(capacity, cap - capacity);
                }
                capacity = cap;
            }
        }

        void insert(uint32_t index, T value, uint32_t count = 1)
        {
            ((index <= len) ? static_cast<void> (0) : __assert_fail ("index <= len", "./nanojit/avmplus.h", 632, __PRETTY_FUNCTION__));
            ((count > 0) ? static_cast<void> (0) : __assert_fail ("count > 0", "./nanojit/avmplus.h", 633, __PRETTY_FUNCTION__));
            ensureCapacity(len+count);
            memmove(data + index + count, data + index, factor(len - index));
            wbzm(index, index+count, value);
            len += count;
        }

        T removeAt(uint32_t index)
        {
            T old = get(index);

            wb(index, undef_list_val());
            memmove(data + index, data + index + 1, factor(len - index - 1));
            len--;
            return old;
        }

    private:
        void grow()
        {

            uint32_t newMax = 0;
            const uint32_t curMax = capacity;
            if (curMax == 0)
                newMax = kInitialCapacity;
            else if(curMax > 15)
                newMax = curMax * 3/2;
            else
                newMax = curMax * 2;

            ensureCapacity(newMax);
        }

        void arraycopy(const T* src, int srcStart, T* dst, int dstStart, int nbr)
        {

            if ((src == dst) && (srcStart > dstStart) )
            {
                for(int i=0; i<nbr; i++)
                    dst[i+dstStart] = src[i+srcStart];
            }
            else
            {
                for(int i=nbr-1; i>=0; i--)
                    dst[i+dstStart] = src[i+srcStart];
            }
        }

        inline void do_wb_nongc(T* slot, T value)
        {
            *slot = value;
        }

        inline void do_wb_gc(GCObject** slot, const GCObject** value)
        {
            *slot = (GCObject*)*value;
        }

        void wb(uint32_t index, T value)
        {
            ((index < capacity) ? static_cast<void> (0) : __assert_fail ("index < capacity", "./nanojit/avmplus.h", 693, __PRETTY_FUNCTION__));
            ((data != __null) ? static_cast<void> (0) : __assert_fail ("data != __null", "./nanojit/avmplus.h", 694, __PRETTY_FUNCTION__));
            T* slot = &data[index];
            do_wb_nongc(slot, value);
        }





        void wbzm(uint32_t index, uint32_t index_end, T value)
        {
            ((index < capacity) ? static_cast<void> (0) : __assert_fail ("index < capacity", "./nanojit/avmplus.h", 705, __PRETTY_FUNCTION__));
            ((index_end <= capacity) ? static_cast<void> (0) : __assert_fail ("index_end <= capacity", "./nanojit/avmplus.h", 706, __PRETTY_FUNCTION__));
            ((index < index_end) ? static_cast<void> (0) : __assert_fail ("index < index_end", "./nanojit/avmplus.h", 707, __PRETTY_FUNCTION__));
            ((data != __null) ? static_cast<void> (0) : __assert_fail ("data != __null", "./nanojit/avmplus.h", 708, __PRETTY_FUNCTION__));
            T* slot = data + index;
            for ( ; index < index_end; ++index, ++slot)
                do_wb_nongc(slot, value);
        }

        inline uint32_t factor(uint32_t index) const
        {
            return index * sizeof(T);
        }

        void zero_range(uint32_t _first, uint32_t _count)
        {
            memset(data + _first, 0, factor(_count));
        }


        static inline T undef_list_val();

    private:
        List(const List& toCopy);
        void operator=(const List& that);


    private:
        T* data;
        uint32_t len;
        uint32_t capacity;


    };


    template<typename T, ListElementType kElementType>
                 inline T List<T, kElementType>::undef_list_val() { return T(0); }
# 756 "./nanojit/avmplus.h"
    template <class K, class T, ListElementType valType>
    class SortedMap : public GCObject
    {
    public:
        enum { kInitialCapacity= 64 };

        SortedMap(GC* gc, int _capacity=kInitialCapacity)
          : keys(gc, _capacity), values(gc, _capacity)
        {
        }

        bool isEmpty() const
        {
            return keys.size() == 0;
        }

        int size() const
        {
            return keys.size();
        }

        void clear()
        {
            keys.clear();
            values.clear();
        }

        void destroy()
        {
            keys.destroy();
            values.destroy();
        }

        T put(K k, T v)
        {
            if (keys.size() == 0 || k > keys.last())
            {
                keys.add(k);
                values.add(v);
                return (T)v;
            }
            else
            {
                int i = find(k);
                if (i >= 0)
                {
                    T old = values[i];
                    keys.set(i, k);
                    values.set(i, v);
                    return old;
                }
                else
                {
                    i = -i - 1;
                    ((keys.size() != (uint32_t)i) ? static_cast<void> (0) : __assert_fail ("keys.size() != (uint32_t)i", "./nanojit/avmplus.h", 810, __PRETTY_FUNCTION__));
                    keys.insert(i, k);
                    values.insert(i, v);
                    return v;
                }
            }
        }

        T get(K k) const
        {
            int i = find(k);
            return i >= 0 ? values[i] : 0;
        }

        bool get(K k, T& v) const
        {
            int i = find(k);
            if (i >= 0)
            {
                v = values[i];
                return true;
            }
            return false;
        }

        bool containsKey(K k) const
        {
            int i = find(k);
            return (i >= 0) ? true : false;
        }

        T remove(K k)
        {
            int i = find(k);
            return removeAt(i);
        }

        T removeAt(int i)
        {
            T old = values.removeAt(i);
            keys.removeAt(i);
            return old;
        }

        T removeFirst() { return isEmpty() ? (T)0 : removeAt(0); }
        T removeLast() { return isEmpty() ? (T)0 : removeAt(keys.size()-1); }
        T first() const { return isEmpty() ? (T)0 : values[0]; }
        T last() const { return isEmpty() ? (T)0 : values[keys.size()-1]; }

        K firstKey() const { return isEmpty() ? 0 : keys[0]; }
        K lastKey() const { return isEmpty() ? 0 : keys[keys.size()-1]; }


        T at(int i) const { return values[i]; }
        K keyAt(int i) const { return keys[i]; }

        int findNear(K k) const {
            int i = find(k);
            return i >= 0 ? i : -i-2;
        }
    protected:
        List<K, LIST_NonGCObjects> keys;
        List<T, valType> values;

        int find(K k) const
        {
            int lo = 0;
            int hi = keys.size()-1;

            while (lo <= hi)
            {
                int i = (lo + hi)/2;
                K m = keys[i];
                if (k > m)
                    lo = i + 1;
                else if (k < m)
                    hi = i - 1;
                else
                    return i;
            }
            return -(lo + 1);
        }
    };
# 908 "./nanojit/avmplus.h"
    class BitSet
    {
        public:
            enum { kUnit = 8*sizeof(long),
                    kDefaultCapacity = 4 };

            BitSet()
            {
                capacity = kDefaultCapacity;
                reset();
            }

            ~BitSet()
            {
                if (capacity > kDefaultCapacity)
                    free(bits.ptr);
            }

            void reset()
            {
                if (capacity > kDefaultCapacity)
                    for(int i=0; i<capacity; i++)
                        bits.ptr[i] = 0;
                else
                    for(int i=0; i<capacity; i++)
                        bits.ar[i] = 0;
            }

            void set(GC *gc, int bitNbr)
            {
                int index = bitNbr / kUnit;
                int bit = bitNbr % kUnit;
                if (index >= capacity)
                    grow(gc, index+1);

                if (capacity > kDefaultCapacity)
                    bits.ptr[index] |= (1<<bit);
                else
                    bits.ar[index] |= (1<<bit);
            }

            void clear(int bitNbr)
            {
                int index = bitNbr / kUnit;
                int bit = bitNbr % kUnit;
                if (index < capacity)
                {
                    if (capacity > kDefaultCapacity)
                        bits.ptr[index] &= ~(1<<bit);
                    else
                        bits.ar[index] &= ~(1<<bit);
                }
            }

            bool get(int bitNbr) const
            {
                int index = bitNbr / kUnit;
                int bit = bitNbr % kUnit;
                bool value = false;
                if (index < capacity)
                {
                    if (capacity > kDefaultCapacity)
                        value = ( bits.ptr[index] & (1<<bit) ) ? true : false;
                    else
                        value = ( bits.ar[index] & (1<<bit) ) ? true : false;
                }
                return value;
            }

        private:

            void grow(GC *gc, int newCapacity)
            {

                newCapacity *= 2;

                long* newBits = (long*)calloc(1, newCapacity * sizeof(long));



                if (capacity > kDefaultCapacity)
                    for(int i=0; i<capacity; i++)
                        newBits[i] = bits.ptr[i];
                else
                    for(int i=0; i<capacity; i++)
                        newBits[i] = bits.ar[i];


                if (capacity > kDefaultCapacity)
                    free(bits.ptr);

                bits.ptr = newBits;
                capacity = newCapacity;
            }




            int capacity;
            union
            {
                long ar[kDefaultCapacity];
                long* ptr;
            }
            bits;
    };
}
# 44 "./nanojit/nanojit.h" 2
# 111 "./nanojit/nanojit.h"
namespace nanojit
{





 class Fragment;
 class LIns;
 struct SideExit;
 class RegAlloc;
 struct Page;
 typedef avmplus::AvmCore AvmCore;
 typedef avmplus::OSDep OSDep;
 typedef avmplus::SortedMap<const void*,Fragment*,avmplus::LIST_GCObjects> FragmentMap;
 typedef avmplus::SortedMap<SideExit*,RegAlloc*,avmplus::LIST_GCObjects> RegAllocMap;
 typedef avmplus::List<LIns*,avmplus::LIST_NonGCObjects> InsList;
 typedef avmplus::List<char*, avmplus::LIST_GCObjects> StringList;
 typedef avmplus::List<Page*,avmplus::LIST_NonGCObjects> PageList;

    const uint32_t MAXARGS = 8;
# 175 "./nanojit/nanojit.h"
}
# 189 "./nanojit/nanojit.h"
# 1 "./dist/include/system_wrappers_js/stdio.h" 1
       
# 2 "./dist/include/system_wrappers_js/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 190 "./nanojit/nanojit.h" 2
# 238 "./nanojit/nanojit.h"
static inline bool isS32(intptr_t i) {
 return int32_t(i) == i;
}

static inline bool isU32(uintptr_t i) {
 return uint32_t(i) == i;
}
# 254 "./nanojit/nanojit.h"
# 1 "./nanojit/Native.h" 1
# 70 "./nanojit/Native.h"
# 1 "./nanojit/NativeAMD64.h" 1
# 61 "./nanojit/NativeAMD64.h"
namespace nanojit
{
    const int NJ_LOG2_PAGE_SIZE = 12;
    const int NJ_MAX_REGISTERS = 32;
 const int NJ_STACK_OFFSET = 0;





    enum Register {
        RAX = 0,
        RCX = 1,
        RDX = 2,
        RBX = 3,
        RSP = 4,
        RBP = 5,
        RSI = 6,
        RDI = 7,
        R8 = 8,
        R9 = 9,
        R10 = 10,
        R11 = 11,
        R12 = 12,
        R13 = 13,
        R14 = 14,
        R15 = 15,

        XMM0 = 16,
        XMM1 = 17,
        XMM2 = 18,
        XMM3 = 19,
        XMM4 = 20,
        XMM5 = 21,
        XMM6 = 22,
        XMM7 = 23,
        XMM8 = 24,
        XMM9 = 25,
        XMM10 = 26,
        XMM11 = 27,
        XMM12 = 28,
        XMM13 = 29,
        XMM14 = 30,
        XMM15 = 31,

        FP = RBP,
        UnknownReg = 32,
        FirstReg = RAX,
        LastReg = XMM15
    };
# 139 "./nanojit/NativeAMD64.h"
    enum X64Opcode




    {


        X64_addqrr = 0xC003480000000003LL,
        X64_addqri = 0xC081480000000003LL,
        X64_addqr8 = 0x00C0834800000004LL,
        X64_andqri = 0xE081480000000003LL,
        X64_andqr8 = 0x00E0834800000004LL,
        X64_orqri = 0xC881480000000003LL,
        X64_orqr8 = 0x00C8834800000004LL,
        X64_xorqri = 0xF081480000000003LL,
        X64_xorqr8 = 0x00F0834800000004LL,
        X64_addlri = 0xC081400000000003LL,
        X64_addlr8 = 0x00C0834000000004LL,
        X64_andlri = 0xE081400000000003LL,
        X64_andlr8 = 0x00E0834000000004LL,
        X64_orlri = 0xC881400000000003LL,
        X64_orlr8 = 0x00C8834000000004LL,
        X64_sublri = 0xE881400000000003LL,
        X64_sublr8 = 0x00E8834000000004LL,
        X64_xorlri = 0xF081400000000003LL,
        X64_xorlr8 = 0x00F0834000000004LL,
        X64_addrr = 0xC003400000000003LL,
        X64_andqrr = 0xC023480000000003LL,
        X64_andrr = 0xC023400000000003LL,
        X64_call = 0x00000000E8000005LL,
        X64_callrax = 0xD0FF000000000002LL,
        X64_cmovqne = 0xC0450F4800000004LL,
        X64_cmplr = 0xC03B400000000003LL,
        X64_cmpqr = 0xC03B480000000003LL,
        X64_cmplri = 0xF881400000000003LL,
        X64_cmpqri = 0xF881480000000003LL,
        X64_cmplr8 = 0x00F8834000000004LL,
        X64_cmpqr8 = 0x00F8834800000004LL,
        X64_cvtsi2sd= 0xC02A0F40F2000005LL,
        X64_cvtsq2sd= 0xC02A0F48F2000005LL,
        X64_divsd = 0xC05E0F40F2000005LL,
        X64_mulsd = 0xC0590F40F2000005LL,
        X64_addsd = 0xC0580F40F2000005LL,
        X64_imul = 0xC0AF0F4000000004LL,
        X64_imuli = 0xC069400000000003LL,
        X64_imul8 = 0x00C06B4000000004LL,
        X64_jmp = 0x00000000E9000005LL,
        X64_jmp8 = 0x00EB000000000002LL,
        X64_jb = 0x00000000820F0006LL,
        X64_jae = 0x00000000830F0006LL,
        X64_ja = 0x00000000870F0006LL,
        X64_jbe = 0x00000000860F0006LL,
        X64_je = 0x00000000840F0006LL,
        X64_jne = 0x00000000850F0006LL,
        X64_jl = 0x000000008C0F0006LL,
        X64_jge = 0x000000008D0F0006LL,
        X64_jg = 0x000000008F0F0006LL,
        X64_jle = 0x000000008E0F0006LL,
        X64_jp = 0x000000008A0F0006LL,
        X64_jnp = 0x000000008B0F0006LL,
        X64_jneg = 0x0000000001000000LL,
        X64_jb8 = 0x0072000000000002LL,
        X64_jae8 = 0x0073000000000002LL,
        X64_ja8 = 0x0077000000000002LL,
        X64_jbe8 = 0x0076000000000002LL,
        X64_je8 = 0x0074000000000002LL,
        X64_jne8 = 0x0075000000000002LL,
        X64_jl8 = 0x007C000000000002LL,
        X64_jge8 = 0x007D000000000002LL,
        X64_jg8 = 0x007F000000000002LL,
        X64_jle8 = 0x007E000000000002LL,
        X64_jp8 = 0x007A000000000002LL,
        X64_jnp8 = 0x007B000000000002LL,
        X64_jneg8 = 0x0001000000000000LL,
        X64_leaqrm = 0x00000000808D4807LL,
        X64_learm = 0x00000000808D4007LL,
        X64_movlr = 0xC08B400000000003LL,
        X64_movlmr = 0x0000000080894007LL,
        X64_movlrm = 0x00000000808B4007LL,
        X64_movqmr = 0x0000000080894807LL,
        X64_movqspr = 0x0024448948000005LL,
        X64_movqr = 0xC08B480000000003LL,
        X64_movqi = 0xB848000000000002LL,
        X64_movi = 0xB840000000000002LL,
        X64_movqi32 = 0xC0C7480000000003LL,
        X64_movapsr = 0xC0280F4000000004LL,
        X64_movqrx = 0xC07E0F4866000005LL,
        X64_movqxr = 0xC06E0F4866000005LL,
        X64_movqrm = 0x00000000808B4807LL,
        X64_movsdrr = 0xC0100F40F2000005LL,
        X64_movsdrm = 0x80100F40F2000005LL,
        X64_movsdmr = 0x80110F40F2000005LL,
        X64_movsxdr = 0xC063480000000003LL,
        X64_movzx8 = 0xC0B60F4000000004LL,
        X64_neg = 0xD8F7400000000003LL,
        X64_nop1 = 0x9000000000000001LL,
        X64_nop2 = 0x9066000000000002LL,
        X64_nop3 = 0x001F0F0000000003LL,
        X64_nop4 = 0x00401F0F00000004LL,
        X64_nop5 = 0x0000441F0F000005LL,
        X64_nop6 = 0x0000441F0F660006LL,
        X64_nop7 = 0x00000000801F0F07LL,
        X64_not = 0xD0F7400000000003LL,
        X64_orlrr = 0xC00B400000000003LL,
        X64_orqrr = 0xC00B480000000003LL,
        X64_popr = 0x5840000000000002LL,
        X64_pushr = 0x5040000000000002LL,
        X64_pxor = 0xC0EF0F4066000005LL,
        X64_ret = 0xC300000000000001LL,
        X64_sete = 0xC0940F4000000004LL,
        X64_seto = 0xC0900F4000000004LL,
        X64_setc = 0xC0920F4000000004LL,
        X64_setl = 0xC09C0F4000000004LL,
        X64_setle = 0xC09E0F4000000004LL,
        X64_setg = 0xC09F0F4000000004LL,
        X64_setge = 0xC09D0F4000000004LL,
        X64_seta = 0xC0970F4000000004LL,
        X64_setae = 0xC0930F4000000004LL,
        X64_setb = 0xC0920F4000000004LL,
        X64_setbe = 0xC0960F4000000004LL,
        X64_subsd = 0xC05C0F40F2000005LL,
        X64_shl = 0xE0D3400000000003LL,
        X64_shlq = 0xE0D3480000000003LL,
        X64_shr = 0xE8D3400000000003LL,
        X64_shrq = 0xE8D3480000000003LL,
        X64_sar = 0xF8D3400000000003LL,
        X64_sarq = 0xF8D3480000000003LL,
        X64_shli = 0x00E0C14000000004LL,
        X64_shlqi = 0x00E0C14800000004LL,
        X64_sari = 0x00F8C14000000004LL,
        X64_sarqi = 0x00F8C14800000004LL,
        X64_shri = 0x00E8C14000000004LL,
        X64_shrqi = 0x00E8C14800000004LL,
        X64_subqrr = 0xC02B480000000003LL,
        X64_subrr = 0xC02B400000000003LL,
        X64_subqri = 0xE881480000000003LL,
        X64_subqr8 = 0x00E8834800000004LL,
        X64_ucomisd = 0xC02E0F4066000005LL,
        X64_xorqrr = 0xC033480000000003LL,
        X64_xorrr = 0xC033400000000003LL,
        X64_xorpd = 0xC0570F4066000005LL,
        X64_xorps = 0xC0570F4000000004LL,
        X64_xorpsm = 0x05570F4000000004LL,
        X64_xorpsa = 0x2504570F40000005LL,

        X86_and8r = 0xC022000000000002LL,
        X86_sete = 0xC0940F0000000003LL,
        X86_setnp = 0xC09B0F0000000003LL
    };

    typedef uint32_t RegisterMask;

    static const RegisterMask GpRegs = 0xffff;
    static const RegisterMask FpRegs = 0xffff0000;





    static const RegisterMask SavedRegs = 1<<RBX | 1<<R12 | 1<<R13 | 1<<R14 | 1<<R15;
    static const int NumSavedRegs = 5;
    static const int NumArgRegs = 6;


    static inline bool IsFpReg(Register r) {
        return ((1<<r) & FpRegs) != 0;
    }
    static inline bool IsGpReg(Register r) {
        return ((1<<r) & GpRegs) != 0;
    }

    extern const char* regNames[];
# 355 "./nanojit/NativeAMD64.h"
    const int LARGEST_UNDERRUN_PROT = 32;

    typedef uint8_t NIns;

    inline Register nextreg(Register r) {
        return Register(r+1);
    }

}
# 71 "./nanojit/Native.h" 2




namespace nanojit {
 const uint32_t NJ_PAGE_SIZE = 1 << NJ_LOG2_PAGE_SIZE;

    class Fragment;
    struct SideExit;
 struct SwitchInfo;

    struct GuardRecord
    {
        void* jmp;
        GuardRecord* next;
        SideExit* exit;
    };

    struct SideExit
    {
        GuardRecord* guards;
        Fragment* from;
        Fragment* target;
  SwitchInfo* switchInfo;

        void addGuard(GuardRecord* gr)
        {
            do { if (!(gr->next == __null)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "gr->next == __null", "./nanojit/Native.h", 98); NanoAssertFail(); }; } while (0);
            do { if (!(guards != gr)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "guards != gr", "./nanojit/Native.h", 99); NanoAssertFail(); }; } while (0);
            gr->next = guards;
            guards = gr;
        }
    };
}
# 255 "./nanojit/nanojit.h" 2
# 1 "./nanojit/LIR.h" 1
# 57 "./nanojit/LIR.h"
namespace nanojit
{


 enum LOpcode



 {

  LIR64 = 0x40,


        LIR_start = 0,
        LIR_nearskip = 1,
        LIR_skip = 2,
        LIR_neartramp = 3,
        LIR_tramp = 4,


        LIR_iaddp = 9,
        LIR_iparam = 10,
        LIR_st = 11,
        LIR_ld = 12,
        LIR_ialloc = 13,
        LIR_sti = 14,
        LIR_ret = 15,
        LIR_live = 16,
        LIR_icall = 18,


        LIR_loop = 19,
        LIR_x = 20,


        LIR_j = 21,
        LIR_jt = 22,
        LIR_jf = 23,
        LIR_label = 24,
        LIR_ji = 25,




        LIR_feq = 26,
        LIR_flt = 27,
        LIR_fgt = 28,
        LIR_fle = 29,
        LIR_fge = 30,

        LIR_cmov = 31,
        LIR_short = 32,
        LIR_int = 33,
        LIR_ldc = 34,
        LIR_2 = 35,


        LIR_neg = 36,
        LIR_add = 37,
        LIR_sub = 38,
        LIR_mul = 39,
        LIR_callh = 40,
        LIR_and = 41,
        LIR_or = 42,
        LIR_xor = 43,
        LIR_not = 44,
        LIR_lsh = 45,
        LIR_rsh = 46,
        LIR_ush = 47,



        LIR_xt = 48,
        LIR_xf = 49,



        LIR_qlo = 50,
        LIR_qhi = 51,

        LIR_ldcb = 52,

        LIR_ov = 53,
        LIR_cs = 54,
        LIR_eq = 55,



        LIR_lt = 56,
        LIR_gt = 57,
        LIR_le = 58,
        LIR_ge = 59,


        LIR_ult = 60,
        LIR_ugt = 61,
        LIR_ule = 62,
        LIR_uge = 63,



        LIR_file = 1 | LIR64,
        LIR_line = 2 | LIR64,




        LIR_stq = LIR_st | LIR64,
        LIR_stqi = LIR_sti | LIR64,
        LIR_fret = LIR_ret | LIR64,
        LIR_quad = LIR_int | LIR64,
        LIR_ldq = LIR_ld | LIR64,
        LIR_ldqc = LIR_ldc | LIR64,
        LIR_qiand = 24 | LIR64,
        LIR_qiadd = 25 | LIR64,
        LIR_qilsh = LIR_lsh | LIR64,
        LIR_qirsh = LIR_rsh | LIR64,
        LIR_qursh = LIR_ush | LIR64,
        LIR_qparam = LIR_iparam| LIR64,

        LIR_fcall = LIR_icall | LIR64,
        LIR_qcall = 17 | LIR64,
        LIR_fneg = LIR_neg | LIR64,
        LIR_fadd = LIR_add | LIR64,
        LIR_fsub = LIR_sub | LIR64,
        LIR_fmul = LIR_mul | LIR64,
        LIR_fdiv = 40 | LIR64,
        LIR_qcmov = LIR_cmov | LIR64,

        LIR_qjoin = 41 | LIR64,
        LIR_i2f = 48 | LIR64,
        LIR_u2f = 49 | LIR64,
        LIR_i2q = 26 | LIR64,
        LIR_u2q = 27 | LIR64,
        LIR_qaddp = LIR_iaddp | LIR64,
        LIR_qalloc = LIR_ialloc | LIR64,
        LIR_qior = LIR_or | LIR64,
        LIR_qxor = LIR_xor | LIR64,

        LIR_qeq = LIR_eq | LIR64,
        LIR_qlt = LIR_lt | LIR64,
        LIR_qgt = LIR_gt | LIR64,
        LIR_qle = LIR_le | LIR64,
        LIR_qge = LIR_ge | LIR64,
        LIR_qult = LIR_ult | LIR64,
        LIR_qugt = LIR_ugt | LIR64,
        LIR_qule = LIR_ule | LIR64,
        LIR_quge = LIR_uge | LIR64,


        LIR_ldp = LIR_ldq,
        LIR_ldcp = LIR_ldqc,
        LIR_stp = LIR_stq,
        LIR_piadd = LIR_qiadd,
        LIR_piand = LIR_qiand,
        LIR_pilsh = LIR_qilsh,
        LIR_pirsh = LIR_qirsh,
        LIR_pursh = LIR_qursh,
        LIR_pcmov = LIR_qcmov,
        LIR_pior = LIR_qior,
        LIR_pxor = LIR_qxor,
        LIR_addp = LIR_qaddp,
        LIR_peq = LIR_qeq,
        LIR_plt = LIR_qlt,
        LIR_pgt = LIR_qgt,
        LIR_ple = LIR_qle,
        LIR_pge = LIR_qge,
        LIR_pult = LIR_qult,
        LIR_pugt = LIR_qugt,
        LIR_pule = LIR_qule,
        LIR_puge = LIR_quge,
        LIR_alloc = LIR_qalloc,
        LIR_pcall = LIR_qcall,
        LIR_param = LIR_qparam

 };
# 295 "./nanojit/LIR.h"
 inline uint32_t argwords(uint32_t argc) {
  return (argc+3)>>2;
 }

    struct SideExit;

    enum AbiKind {
        ABI_FASTCALL,
        ABI_THISCALL,
  ABI_STDCALL,
        ABI_CDECL
    };

    enum ArgSize {
     ARGSIZE_NONE = 0,
        ARGSIZE_F = 1,
     ARGSIZE_LO = 2,
     ARGSIZE_Q = 3,
        ARGSIZE_U = 6,
        ARGSIZE_MASK = 7,
     _ARGSIZE_MASK_INT = 2,
        _ARGSIZE_MASK_ANY = 3,


        ARGSIZE_I = ARGSIZE_LO,
        ARGSIZE_MASK_INT = _ARGSIZE_MASK_INT,
        ARGSIZE_SHIFT = _ARGSIZE_MASK_ANY,
        ARGSIZE_P = ARGSIZE_Q,
        ARGSIZE_B = ARGSIZE_I,
        ARGSIZE_V = ARGSIZE_NONE

    };

    struct CallInfo
 {
  uintptr_t _address;
        uint32_t _argtypes:18;
        uint8_t _cse:1;
        uint8_t _fold:1;
        AbiKind _abi:3;
  const char* _name;

  uint32_t _count_args(uint32_t mask) const;
        uint32_t get_sizes(ArgSize*) const;

        inline bool isInterface() const {
            return _address == 2 || _address == 3;
        }
        inline bool isIndirect() const {
            return _address < 256;
        }
  inline uint32_t count_args() const {
            return _count_args(_ARGSIZE_MASK_ANY) + isIndirect();
        }
  inline uint32_t count_iargs() const {
            return _count_args(_ARGSIZE_MASK_INT);
        }

 };




 struct SwitchInfo
 {
  NIns** table;
  uint32_t count;



  uint32_t index;
 };

    inline bool isGuard(LOpcode op) {

        return op == LIR_x || op == LIR_xf || op == LIR_xt || op == LIR_loop || op == LIR_neartramp || op == LIR_tramp;
    }

    inline bool isCall(LOpcode op) {
        return (op & ~LIR64) == LIR_icall || op == LIR_qcall;
    }

    inline bool isStore(LOpcode op) {
        op = LOpcode(op & ~LIR64);
        return op == LIR_st || op == LIR_sti;
    }

    inline bool isConst(LOpcode op) {
        extern void nano_static_assert(int arg[((LIR_short & 1) == 0) ? 1 : -1]);
        extern void nano_static_assert(int arg[(LIR_int == LIR_short + 1) ? 1 : -1]);
        return (op & ~1) == LIR_short;
    }

    inline bool isLoad(LOpcode op) {
        return op == LIR_ldq || op == LIR_ld || op == LIR_ldc || op == LIR_ldqc ;
    }
# 401 "./nanojit/LIR.h"
 class LIns
 {
        friend class LirBufWriter;

  struct u_type
  {
   LOpcode code:8;
   uint32_t oprnd_3:8;
   uint32_t oprnd_1:8;
   uint32_t oprnd_2:8;
  };

        struct sti_type
        {
   LOpcode code:8;
   int32_t disp:8;
   uint32_t oprnd_1:8;
   uint32_t oprnd_2:8;
        };


  struct c_type
  {
   LOpcode code:8;
   uint32_t resv:8;
   uint32_t imm8a:8;
   uint32_t imm8b:8;
  };


        struct t_type
        {
            LOpcode code:8;
            int32_t imm24:24;
        };


  struct i_type
  {
   LOpcode code:8;
   uint32_t resv:8;
   int32_t imm16:16;
  };


  struct g_type
  {
   LOpcode code:8;
   uint32_t resv:8;
   uint32_t unused:16;
  };
# 464 "./nanojit/LIR.h"
  union
  {
   u_type u;
   c_type c;
   i_type i;
            t_type t;
   g_type g;
            sti_type sti;
  };

  enum {
   callInfoWords = sizeof(LIns*)/sizeof(u_type)
  };

  uint32_t reference(LIns*) const;
  LIns* deref(int32_t off) const;

 public:
  LIns* oprnd1() const;
  LIns* oprnd2() const;
  LIns* oprnd3() const;

  inline LOpcode opcode() const { return u.code; }
  inline uint8_t imm8() const { return c.imm8a; }
  inline uint8_t imm8b() const { return c.imm8b; }
  inline int16_t imm16() const { return i.imm16; }
  inline int32_t imm24() const { return t.imm24; }
  LIns* ref() const;
  int32_t imm32() const;
  inline uint8_t resv() const { return g.resv; }
        void* payload() const;
        inline Page* page() { return (Page*) ((((uintptr_t)(this)))&~(((uintptr_t)NJ_PAGE_SIZE)-1)); }
        inline int32_t size() const {
            do { if (!(isop(LIR_alloc))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "isop(LIR_alloc)", "./nanojit/LIR.h", 497); NanoAssertFail(); }; } while (0);
            return i.imm16<<2;
        }
        inline void setSize(int32_t bytes) {
            do { if (!(isop(LIR_alloc) && (bytes&3)==0 && ( int32_t(bytes>>2) == uint16_t(bytes>>2) ))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "isop(LIR_alloc) && (bytes&3)==0 && ( int32_t(bytes>>2) == uint16_t(bytes>>2) )", "./nanojit/LIR.h", 501); NanoAssertFail(); }; } while (0);
            i.imm16 = bytes>>2;
        }

  LIns* arg(uint32_t i);

        inline int32_t immdisp()const
  {
            return (u.code&~LIR64) == LIR_sti ? sti.disp : oprnd3()->constval();
        }

  inline static bool sameop(LIns* a, LIns* b)
  {

   union {
    uint32_t x;
    u_type u;
   } tmp;
   tmp.x = *(uint32_t*)a ^ *(uint32_t*)b;
   return tmp.u.code == 0;
  }

  inline int32_t constval() const
  {
   do { if (!(isconst())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "isconst()", "./nanojit/LIR.h", 525); NanoAssertFail(); }; } while (0);
   return isop(LIR_short) ? imm16() : imm32();
  }

  uint64_t constvalq() const;

  inline void* constvalp() const
  {



      return (void*)constval();

  }

  double constvalf() const;
  bool isCse(const CallInfo *functions) const;
  bool isop(LOpcode o) const { return u.code == o; }
  bool isQuad() const;
  bool isCond() const;
  bool isCmp() const;
  bool isCall() const { return nanojit::isCall(u.code); }
        bool isStore() const { return nanojit::isStore(u.code); }
        bool isLoad() const { return nanojit::isLoad(u.code); }
  bool isGuard() const { return nanojit::isGuard(u.code); }

  bool isconst() const { return nanojit::isConst(u.code); }


  bool isconstval(int32_t val) const;

  bool isconstq() const;

  bool isconstp() const;
        bool isTramp() {
            return isop(LIR_neartramp) || isop(LIR_tramp);
        }
  bool isBranch() const {
   return isop(LIR_jt) || isop(LIR_jf) || isop(LIR_j);
  }


  void setimm16(int32_t i);
  void setimm24(int32_t x);


  void setresv(uint32_t resv);

  void initOpcode(LOpcode);

  void setOprnd1(LIns*);
  void setOprnd2(LIns*);
  void setOprnd3(LIns*);
        void setDisp(int8_t d);
  void target(LIns* t);
        LIns **targetAddr();
  LIns* getTarget();

        GuardRecord *record();

  inline uint32_t argc() const {
   do { if (!(isCall())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "isCall()", "./nanojit/LIR.h", 586); NanoAssertFail(); }; } while (0);
   return c.imm8b;
  }
  size_t callInsWords() const;
  const CallInfo *callInfo() const;
 };
 typedef LIns* LInsp;

 typedef struct { LIns* v; LIns i; } LirFarIns;
 typedef struct { int32_t v; LIns i; } LirImm32Ins;
 typedef struct { int32_t v[2]; LIns i; } LirImm64Ins;
 typedef struct { const CallInfo* ci; LIns i; } LirCallIns;

 static const uint32_t LIR_FAR_SLOTS = sizeof(LirFarIns)/sizeof(LIns);
 static const uint32_t LIR_CALL_SLOTS = sizeof(LirCallIns)/sizeof(LIns);
 static const uint32_t LIR_IMM32_SLOTS = sizeof(LirImm32Ins)/sizeof(LIns);
 static const uint32_t LIR_IMM64_SLOTS = sizeof(LirImm64Ins)/sizeof(LIns);
# 612 "./nanojit/LIR.h"
 bool isCse(LOpcode v);
 bool isCmp(LOpcode v);
 bool isCond(LOpcode v);
    inline bool isRet(LOpcode c) {
        return (c & ~LIR64) == LIR_ret;
    }
    bool isFloat(LOpcode v);
 LIns* callArgN(LInsp i, uint32_t n);
 extern const uint8_t operandCount[];

 class Fragmento;
 class LirFilter;


 class LirWriter : public avmplus::GCObject
 {
 public:
  LirWriter *out;
        const CallInfo *_functions;

  virtual ~LirWriter() {}
  LirWriter(LirWriter* out)
   : out(out), _functions(out?out->_functions : 0) {}

  virtual LInsp ins0(LOpcode v) {
   return out->ins0(v);
  }
  virtual LInsp ins1(LOpcode v, LIns* a) {
   return out->ins1(v, a);
  }
  virtual LInsp ins2(LOpcode v, LIns* a, LIns* b) {
   return out->ins2(v, a, b);
  }
  virtual LInsp insGuard(LOpcode v, LIns *c, LIns *x) {
   return out->insGuard(v, c, x);
  }
  virtual LInsp insBranch(LOpcode v, LInsp condition, LInsp to) {
   return out->insBranch(v, condition, to);
  }


  virtual LInsp insParam(int32_t arg, int32_t kind) {
   return out->insParam(arg, kind);
  }
  virtual LInsp insImm(int32_t imm) {
   return out->insImm(imm);
  }
  virtual LInsp insImmq(uint64_t imm) {
   return out->insImmq(imm);
  }
  virtual LInsp insLoad(LOpcode op, LIns* base, LIns* d) {
   return out->insLoad(op, base, d);
  }
  virtual LInsp insStore(LIns* value, LIns* base, LIns* disp) {
   return out->insStore(value, base, disp);
  }
  virtual LInsp insStorei(LIns* value, LIns* base, int32_t d) {
   return ( int32_t(d) == int8_t(d) ) ? out->insStorei(value, base, d)
    : out->insStore(value, base, insImm(d));
  }
  virtual LInsp insCall(const CallInfo *call, LInsp args[]) {
   return out->insCall(call, args);
  }
  virtual LInsp insAlloc(int32_t size) {
   return out->insAlloc(size);
  }
  virtual LInsp skip(size_t size) {
   return out->skip(size);
  }


     LIns* insLoadi(LIns *base, int disp);
     LIns* insLoad(LOpcode op, LIns *base, int disp);
     LIns* store(LIns* value, LIns* base, int32_t d);


     LIns* ins_choose(LIns* cond, LIns* iftrue, LIns* iffalse);

     LIns* ins_eq0(LIns* oprnd1);


        LIns* ins2i(LOpcode op, LIns *oprnd1, int32_t);
  LIns* qjoin(LInsp lo, LInsp hi);
  LIns* insImmPtr(const void *ptr);
  LIns* insImmf(double f);
 };


 extern const char* lirNames[];




    class LabelMap : public avmplus::GCObject
    {
  LabelMap* parent;
  class Entry : public avmplus::GCObject
  {
  public:
   Entry(int) : name(0), size(0), align(0) {}
   Entry(avmplus::String *n, size_t s, size_t a) : name(n),size(s),align(a) {}
            ~Entry();
   avmplus::String* name;
   size_t size:29, align:3;
  };
        avmplus::SortedMap<const void*, Entry*, avmplus::LIST_GCObjects> names;
  bool addrs, pad[3];
  char buf[1000], *end;
        void formatAddr(const void *p, char *buf);
    public:
        avmplus::AvmCore *core;
        LabelMap(avmplus::AvmCore *, LabelMap* parent);
        ~LabelMap();
        void add(const void *p, size_t size, size_t align, const char *name);
  void add(const void *p, size_t size, size_t align, avmplus::String*);
  const char *dup(const char *);
  const char *format(const void *p);
  void promoteAll(const void *newbase);
  void clear();
    };

 class LirNameMap : public avmplus::GCObject
 {
  template <class Key>
  class CountMap: public avmplus::SortedMap<Key, int, avmplus::LIST_NonGCObjects> {
  public:
   CountMap(avmplus::GC*gc) : avmplus::SortedMap<Key, int, avmplus::LIST_NonGCObjects>(gc) {}
   int add(Key k) {
    int c = 1;
    if (containsKey(k)) {
     c = 1+get(k);
    }
    put(k,c);
    return c;
   }
  };
  CountMap<int> lircounts;
  CountMap<const CallInfo *> funccounts;

  class Entry : public avmplus::GCObject
  {
  public:
   Entry(int) : name(0) {}
   Entry(avmplus::String *n) : name(n) {}
            ~Entry();
   avmplus::String* name;
  };
  avmplus::SortedMap<LInsp, Entry*, avmplus::LIST_GCObjects> names;
  const CallInfo *_functions;
  LabelMap *labels;
  void formatImm(int32_t c, char *buf);
 public:

  LirNameMap(avmplus::GC *gc, const CallInfo *_functions, LabelMap *r)
   : lircounts(gc),
   funccounts(gc),
   names(gc),
   _functions(_functions),
   labels(r)
  {}
        ~LirNameMap();

  void addName(LInsp i, const char *s);
  bool addName(LInsp i, avmplus::String *s);
  void copyName(LInsp i, const char *s, int suffix);
        const char *formatRef(LIns *ref);
  const char *formatIns(LInsp i);
  void formatGuard(LInsp i, char *buf);
 };


 class VerboseWriter : public LirWriter
 {
  InsList code;
  LirNameMap* names;
    public:
  VerboseWriter(avmplus::GC *gc, LirWriter *out, LirNameMap* names)
   : LirWriter(out), code(gc), names(names)
  {}

  LInsp add(LInsp i) {
            if (i)
                code.add(i);
   return i;
  }

        LInsp add_flush(LInsp i) {
            if ((i = add(i)) != 0)
                flush();
            return i;
        }

  void flush()
  {
            int n = code.size();
            if (n) {
       for (int i=0; i < n; i++)
        printf("    %s\n",names->formatIns(code[i]));
       code.clear();
                if (n > 1)
           printf("\n");
            }
  }

  LIns* insGuard(LOpcode op, LInsp cond, LIns *x) {
   return add_flush(out->insGuard(op,cond,x));
  }

  LIns* insBranch(LOpcode v, LInsp condition, LInsp to) {
   return add_flush(out->insBranch(v, condition, to));
  }

  LIns* ins0(LOpcode v) {
            if (v == LIR_label || v == LIR_start) {
                flush();
            }
   return add(out->ins0(v));
  }

  LIns* ins1(LOpcode v, LInsp a) {
            return isRet(v) ? add_flush(out->ins1(v, a)) : add(out->ins1(v, a));
  }
  LIns* ins2(LOpcode v, LInsp a, LInsp b) {
   return v == LIR_2 ? out->ins2(v,a,b) : add(out->ins2(v, a, b));
  }
  LIns* insCall(const CallInfo *call, LInsp args[]) {
   return add_flush(out->insCall(call, args));
  }
  LIns* insParam(int32_t i, int32_t kind) {
   return add(out->insParam(i, kind));
  }
  LIns* insLoad(LOpcode v, LInsp base, LInsp disp) {
   return add(out->insLoad(v, base, disp));
  }
  LIns* insStore(LInsp v, LInsp b, LInsp d) {
   return add(out->insStore(v, b, d));
  }
  LIns* insStorei(LInsp v, LInsp b, int32_t d) {
   return add(out->insStorei(v, b, d));
  }
        LIns* insAlloc(int32_t size) {
            return add(out->insAlloc(size));
        }
        LIns* insImm(int32_t imm) {
            return add(out->insImm(imm));
        }
        LIns* insImmq(uint64_t imm) {
            return add(out->insImmq(imm));
        }
    };



 class ExprFilter: public LirWriter
 {
 public:
  ExprFilter(LirWriter *out) : LirWriter(out) {}
  LIns* ins1(LOpcode v, LIns* a);
     LIns* ins2(LOpcode v, LIns* a, LIns* b);
  LIns* insGuard(LOpcode, LIns *cond, LIns *);
        LIns* insBranch(LOpcode, LIns *cond, LIns *target);
 };


 class LInsHashSet
 {



  static const uint32_t kInitialCap = 64;

  LInsp *m_list;
  uint32_t m_used, m_cap;
  avmplus::GC* m_gc;

  static uint32_t hashcode(LInsp i);
  uint32_t find(LInsp name, uint32_t hash, const LInsp *list, uint32_t cap);
  static bool equals(LInsp a, LInsp b);
  void grow();

 public:

  LInsHashSet(avmplus::GC* gc);
  ~LInsHashSet();
  LInsp find32(int32_t a, uint32_t &i);
  LInsp find64(uint64_t a, uint32_t &i);
  LInsp find1(LOpcode v, LInsp a, uint32_t &i);
  LInsp find2(LOpcode v, LInsp a, LInsp b, uint32_t &i);
  LInsp findcall(const CallInfo *call, uint32_t argc, LInsp args[], uint32_t &i);
  LInsp add(LInsp i, uint32_t k);
  void replace(LInsp i);
        void clear();

  static uint32_t hashimm(int32_t);
  static uint32_t hashimmq(uint64_t);
  static uint32_t hash1(LOpcode v, LInsp);
  static uint32_t hash2(LOpcode v, LInsp, LInsp);
  static uint32_t hashcall(const CallInfo *call, uint32_t argc, LInsp args[]);
 };

 class CseFilter: public LirWriter
 {
 public:
  LInsHashSet exprs;
  CseFilter(LirWriter *out, avmplus::GC *gc);
     LIns* insImm(int32_t imm);
     LIns* insImmq(uint64_t q);
     LIns* ins0(LOpcode v);
  LIns* ins1(LOpcode v, LInsp);
  LIns* ins2(LOpcode v, LInsp, LInsp);
  LIns* insLoad(LOpcode v, LInsp b, LInsp d);
  LIns* insCall(const CallInfo *call, LInsp args[]);
  LIns* insGuard(LOpcode op, LInsp cond, LIns *x);
 };

 class LirBuffer : public avmplus::GCFinalizedObject
 {
  public:
   Fragmento* _frago;
   LirBuffer(Fragmento* frago, const CallInfo* functions);
   virtual ~LirBuffer();
   void clear();
            void rewind();
   LInsp next();
   bool outOMem() { return _noMem != 0; }

   void validate() const;
   LirNameMap* names;

   int32_t insCount();
   int32_t byteCount();


   struct
   {
    uint32_t lir;
   }
   _stats;

   const CallInfo* _functions;
            AbiKind abi;
            LInsp state,param1,sp,rp;
            LInsp savedRegs[NumSavedRegs];
            bool explicitSavedRegs;

  protected:
   friend class LirBufWriter;

   LInsp commit(uint32_t count);
   Page* pageAlloc();

   PageList _pages;
   Page* _nextPage;
   LInsp _unused;
   int _noMem;
 };

 class LirBufWriter : public LirWriter
 {
  LirBuffer* _buf;
        LInsp spref, rpref;

        public:
   LirBufWriter(LirBuffer* buf)
    : LirWriter(0), _buf(buf) {
    _functions = buf->_functions;
   }


   LInsp insLoad(LOpcode op, LInsp base, LInsp off);
   LInsp insStore(LInsp o1, LInsp o2, LInsp o3);
   LInsp insStorei(LInsp o1, LInsp o2, int32_t imm);
   LInsp ins0(LOpcode op);
   LInsp ins1(LOpcode op, LInsp o1);
   LInsp ins2(LOpcode op, LInsp o1, LInsp o2);
   LInsp insParam(int32_t i, int32_t kind);
   LInsp insImm(int32_t imm);
   LInsp insImmq(uint64_t imm);
      LInsp insCall(const CallInfo *call, LInsp args[]);
   LInsp insGuard(LOpcode op, LInsp cond, LIns *x);
   LInsp insBranch(LOpcode v, LInsp condition, LInsp to);
            LInsp insAlloc(int32_t size);


   LInsp skip(size_t);

  protected:
   LInsp insFar(LOpcode op, LInsp target);
   void ensureRoom(uint32_t count);
   bool can8bReach(LInsp from, LInsp to) { return ( int32_t(from-to-1) == uint8_t(from-to-1) ); }
   bool can24bReach(LInsp from, LInsp to){ return ( ((int32_t(to-from)<<8)>>8) == (to-from) ); }
   void prepFor(LInsp& i1, LInsp& i2, LInsp& i3);
   void makeReachable(LInsp& o, LInsp from);

  private:
   LInsp insLinkTo(LOpcode op, LInsp to);
   LInsp insLinkToFar(LOpcode op, LInsp to);
 };

 class LirFilter
 {
 public:
  LirFilter *in;
  LirFilter(LirFilter *in) : in(in) {}
        virtual ~LirFilter(){}

  virtual LInsp read() {
   return in->read();
  }
  virtual LInsp pos() {
   return in->pos();
  }
 };


 class LirReader : public LirFilter
 {
  LInsp _i;

 public:
  LirReader(LirBuffer* buf) : LirFilter(0), _i(buf->next()-1) { }
  LirReader(LInsp i) : LirFilter(0), _i(i) { }
  virtual ~LirReader() {}


  LInsp read();
  LInsp pos() {
   return _i;
  }
        void setpos(LIns *i) {
            _i = i;
        }
 };

    class Assembler;

    void compile(Assembler *assm, Fragment *frag);
 void live(avmplus::GC *gc, LirBuffer *lirbuf);

 class StackFilter: public LirFilter
 {
     avmplus::GC *gc;
  LirBuffer *lirbuf;
  LInsp sp;
  avmplus::BitSet stk;
        int top;
  int getTop(LInsp br);
 public:
     StackFilter(LirFilter *in, avmplus::GC *gc, LirBuffer *lirbuf, LInsp sp);
  virtual ~StackFilter() {}
  LInsp read();
 };

 class CseReader: public LirFilter
 {
  LInsHashSet *exprs;
  const CallInfo *functions;
 public:
  CseReader(LirFilter *in, LInsHashSet *exprs, const CallInfo*);
  LInsp read();
 };


    class LoadFilter: public LirWriter
    {
    public:
        LInsp sp, rp;
        LInsHashSet exprs;
        void clear(LInsp p);
    public:
        LoadFilter(LirWriter *out, avmplus::GC *gc)
            : LirWriter(out), exprs(gc) { }

        LInsp ins0(LOpcode);
        LInsp insLoad(LOpcode, LInsp base, LInsp disp);
        LInsp insStore(LInsp v, LInsp b, LInsp d);
        LInsp insStorei(LInsp v, LInsp b, int32_t d);
        LInsp insCall(const CallInfo *call, LInsp args[]);
    };
}
# 256 "./nanojit/nanojit.h" 2
# 1 "./nanojit/RegAlloc.h" 1
# 44 "./nanojit/RegAlloc.h"
namespace nanojit
{
 inline RegisterMask rmask(Register r)
 {
  return 1 << r;
 }

 class RegAlloc : public avmplus::GCObject
 {
  public:
            RegAlloc() : free(0), used(0), priority(0) {}
   void clear();
   bool isFree(Register r);
   void addFree(Register r);
   void removeFree(Register r);
   void addActive(Register r, LIns* ins);
            void useActive(Register r);
   void removeActive(Register r);
   void retire(Register r);
            bool isValid() {
                return (free|used) != 0;
            }

            int32_t getPriority(Register r) {
                do { if (!(r != UnknownReg && active[r])) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "r != UnknownReg && active[r]", "./nanojit/RegAlloc.h", 68); NanoAssertFail(); }; } while (0);
                return usepri[r];
            }

         LIns* getActive(Register r) {
          do { if (!(r != UnknownReg)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "r != UnknownReg", "./nanojit/RegAlloc.h", 73); NanoAssertFail(); }; } while (0);
          return active[r];
         }

   uint32_t countFree();
   uint32_t countActive();
   void checkCount();
   bool isConsistent(Register r, LIns* v);
   uint32_t count;
   RegisterMask managed;

   LIns* active[LastReg + 1];
   int32_t usepri[LastReg + 1];
   RegisterMask free;
   RegisterMask used;
            int32_t priority;

   static void formatRegisters(RegAlloc& regs, char* s, Fragment*);

  
 };
}
# 257 "./nanojit/nanojit.h" 2
# 1 "./nanojit/Fragmento.h" 1
# 49 "./nanojit/Fragmento.h"
namespace nanojit
{
 struct GuardRecord;
 class Assembler;

    struct PageHeader
    {
        struct Page *next;
    };
    struct Page: public PageHeader
    {
        union {
            LIns lir[(NJ_PAGE_SIZE-sizeof(PageHeader))/sizeof(LIns)];
            NIns code[(NJ_PAGE_SIZE-sizeof(PageHeader))/sizeof(NIns)];
        };
    };
    struct AllocEntry : public avmplus::GCObject
    {
        Page *page;
        uint32_t allocSize;
    };
 typedef avmplus::List<AllocEntry*,avmplus::LIST_NonGCObjects> AllocList;

 typedef avmplus::SortedMap<const void*, uint32_t, avmplus::LIST_NonGCObjects> BlockSortedMap;
 class BlockHist: public BlockSortedMap
 {
 public:
  BlockHist(avmplus::GC*gc) : BlockSortedMap(gc)
  {
  }
  uint32_t count(const void *p) {
   uint32_t c = 1+get(p);
   put(p, c);
   return c;
  }
 };

 struct fragstats;




 class Fragmento : public avmplus::GCFinalizedObject
 {
  public:
   Fragmento(AvmCore* core, uint32_t cacheSizeLog2);
   ~Fragmento();

   void addMemory(void* firstPage, uint32_t pageCount);
   Assembler* assm();
   AvmCore* core();
   Page* pageAlloc();
   void pageFree(Page* page);
   void pagesRelease(PageList& list);

            Fragment* getLoop(const void* ip);
            Fragment* getAnchor(const void* ip);




      void clearFrag(const void* ip);
   void clearFrags();
            Fragment* getMerge(GuardRecord *lr, const void* ip);
            Fragment* createBranch(SideExit *exit, const void* ip);
            Fragment* newFrag(const void* ip);
            Fragment* newBranch(Fragment *from, const void* ip);

            uint32_t pageCount();
   void dumpStats();
   void dumpRatio(const char*, BlockHist*);
   void dumpFragStats(Fragment*, int level, fragstats&);
   void countBlock(BlockHist*, const void* pc);
   void countIL(uint32_t il, uint32_t abc);
   void addLabel(Fragment* f, const char *prefix, int id);


   struct
   {
    uint32_t pages;
    uint32_t maxPageUse;
    uint32_t flushes, ilsize, abcsize, compiles, totalCompiles;
   }
   _stats;

   BlockHist* enterCounts;
   BlockHist* mergeCounts;
   LabelMap* labels;





   uint32_t cacheUsed() const { return (_stats.pages-_freePages.size())<<NJ_LOG2_PAGE_SIZE; }
   uint32_t cacheUsedMax() const { return (_stats.maxPageUse)<<NJ_LOG2_PAGE_SIZE; }
      void clearFragment(Fragment *f);
  private:
   void pagesGrow(int32_t count);
   void trackPages();

   AvmCore* _core;
   Assembler* _assm;
   FragmentMap _frags;
   PageList _freePages;


   AllocList _allocList;
   avmplus::GCHeap* _gcHeap;

   const uint32_t _max_pages;
   uint32_t _pagesGrowth;
 };

 enum TraceKind {
  LoopTrace,
  BranchTrace,
  MergeTrace
 };
# 175 "./nanojit/Fragmento.h"
 class Fragment : public avmplus::GCFinalizedObject
 {
  public:
   Fragment(const void*);
   ~Fragment();

   NIns* code() { return _code; }
   void setCode(NIns* codee, Page* pages) { _code = codee; _pages = pages; }
   GuardRecord* links() { return _links; }
   int32_t& hits() { return _hits; }
            void resetHits();
            void blacklist();
   bool isBlacklisted() { return _hits < 0; }
   bool hasOnlyTreeLinks();
   void releaseLirBuffer();
   void releaseCode(Fragmento* frago);
   void releaseTreeMem(Fragmento* frago);
   bool isAnchor() { return anchor == this; }
   bool isRoot() { return root == this; }
   void onDestroy();

   uint32_t _called;
   uint32_t _native;
            uint32_t _exitNative;
   uint32_t _lir;
   uint32_t _lirbytes;
   const char* _token;
            uint64_t traceTicks;
            uint64_t interpTicks;
   Fragment* eot_target;
   uint32_t sid;
   uint32_t compileNbr;

            Fragment* treeBranches;
            Fragment* branches;
            Fragment* nextbranch;
            Fragment* anchor;
            Fragment* root;
            Fragment* parent;
            Fragment* first;
            Fragment* peer;
            LirBuffer* lirbuf;
   LIns* lastIns;
   SideExit* spawnedFrom;

   TraceKind kind;
   const void* ip;
   uint32_t guardCount;
            uint32_t xjumpCount;
            uint32_t recordAttempts;
            int32_t blacklistLevel;
            NIns* fragEntry;
            NIns* loopEntry;
   void* vmprivate;

  private:
   NIns* _code;
   GuardRecord* _links;
   int32_t _hits;
   Page* _pages;
 };
}
# 258 "./nanojit/nanojit.h" 2
# 1 "./nanojit/Assembler.h" 1
# 44 "./nanojit/Assembler.h"
namespace nanojit
{
# 73 "./nanojit/Assembler.h"
    struct Reservation
 {
  uint32_t arIndex:16;
  Register reg:15;
        uint32_t used:1;
 };

 struct AR
 {
  LIns* entry[ 256 ];
  uint32_t tos;
  uint32_t highwatermark;
  uint32_t lowwatermark;
 };







 struct Stats
 {
  int32_t steals;
  int32_t remats;
  int32_t spills;
  int32_t native;
        int32_t exitnative;

  int32_t pages;
  NIns* codeStart;
  NIns* codeExitStart;

 


  bool pad[4];

 };

 class Fragmento;


 enum AssmError
 {
   None = 0
  ,OutOMem
  ,StackFull
  ,ResvFull
  ,RegionFull
        ,MaxLength
        ,MaxExit
        ,MaxXJump
        ,UnknownPrim
        ,UnknownBranch
 };

 typedef avmplus::List<NIns*, avmplus::LIST_NonGCObjects> NInsList;
 typedef avmplus::SortedMap<LIns*,NIns*,avmplus::LIST_NonGCObjects> InsMap;
 typedef avmplus::SortedMap<NIns*,LIns*,avmplus::LIST_NonGCObjects> NInsMap;

    class LabelState : public avmplus::GCObject
    {
    public:
        RegAlloc regs;
        NIns *addr;
        LabelState(NIns *a, RegAlloc &r) : regs(r), addr(a)
        {}
    };

    class LabelStateMap
    {
        avmplus::GC *gc;
        avmplus::SortedMap<LIns*, LabelState*, avmplus::LIST_GCObjects> labels;
    public:
        LabelStateMap(avmplus::GC *gc) : gc(gc), labels(gc)
        {}
        ~LabelStateMap();

        void clear();
        void add(LIns *label, NIns *addr, RegAlloc &regs);
        LabelState *get(LIns *);
    };







 class Assembler : public avmplus::GCObject
 {
  friend class DeadCodeFilter;
  friend class VerboseBlockReader;
  public:

   static char outline[8192];
   static char outlineEOL[512];
   static char* outputAlign(char* s, int col);

   void outputForEOL(const char* format, ...);
   void output(const char* s);
   void outputf(const char* format, ...);
   void output_asm(const char* s);

   bool _verbose, outputAddr, vpad[2];
   void printActivationState();

   StringList* _outputCache;


   Assembler(Fragmento* frago);
            ~Assembler() {}

   void assemble(Fragment* frag, NInsList& loopJumps);
   void endAssembly(Fragment* frag, NInsList& loopJumps);
   void beginAssembly(Fragment *frag, RegAllocMap* map);
   void copyRegisters(RegAlloc* copyTo);
   void releaseRegisters();
            void patch(GuardRecord *lr);
            void patch(SideExit *exit);



   AssmError error() { return _err; }
   void setError(AssmError e) { _err = e; }
   void setCallTable(const CallInfo *functions);
   void pageReset();
   int32_t codeBytes();
   Page* handoverPages(bool exitPages=false);

   void pageValidate();
   bool onPage(NIns* where, bool exitPages=false);


   void resourceConsistencyCheck();
   void registerConsistencyCheck();

   Stats _stats;
            int hasLoop;

  private:

   void gen(LirFilter* toCompile, NInsList& loopJumps);
   NIns* genPrologue();
   NIns* genEpilogue();

   uint32_t arReserve(LIns* l);
   void arFree(uint32_t idx);
   void arReset();

   Register registerAlloc(RegisterMask allow);
   void registerResetAll();
   void evictRegs(RegisterMask regs);
            void evictScratchRegs();
   void intersectRegisterState(RegAlloc& saved);
   void unionRegisterState(RegAlloc& saved);
            void assignSaved(RegAlloc &saved, RegisterMask skip);
         LInsp findVictim(RegAlloc& regs, RegisterMask allow);

            Register getBaseReg(LIns *i, int &d, RegisterMask allow);
            int findMemFor(LIns* i);
   Register findRegFor(LIns* i, RegisterMask allow);
   void findRegFor2(RegisterMask allow, LIns* ia, Reservation* &ra, LIns *ib, Reservation* &rb);
   Register findSpecificRegFor(LIns* i, Register w);
   Register prepResultReg(LIns *i, RegisterMask allow);
   void freeRsrcOf(LIns *i, bool pop);
   void evict(Register r);
   RegisterMask hint(LIns*i, RegisterMask allow);

   NIns* pageAlloc(bool exitPage=false);
   void pagesFree(Page*& list);
   void internalReset();
            bool canRemat(LIns*);

   Reservation* reserveAlloc(LInsp i);
   void reserveFree(LInsp i);
   void reserveReset();

   Reservation* getresv(LIns *x) {
                uint32_t resv_index = x->resv();
                return resv_index ? &_resvTable[resv_index] : 0;
            }

   Fragmento* _frago;
   avmplus::GC* _gc;
            Fragment* _thisfrag;
   RegAllocMap* _branchStateMap;

   const CallInfo *_functions;

   NIns* _nIns;
   NIns* _nExitIns;
   NIns* _startingIns;
   NIns* _epilogue;
   Page* _nativePages;
   Page* _nativeExitPages;
   AssmError _err;







   AR _activation;
   RegAlloc _allocator;

   LabelStateMap _labels;
   NInsMap _patches;
   Reservation _resvTable[ 256 ];
   uint32_t _resvFree;
   bool _inExit, vpad2[3];
            InsList pending_lives;

   void asm_cmp(LIns *cond);
   void asm_fcmp(LIns *cond);
            void asm_setcc(Register res, LIns *cond);
            NIns * asm_jmpcc(bool brOnFalse, LIns *cond, NIns *target);
   void asm_mmq(Register rd, int dd, Register rs, int ds);
            NIns* asm_exit(LInsp guard);
   NIns* asm_leave_trace(LInsp guard);
            void asm_qjoin(LIns *ins);
            void asm_store32(LIns *val, int d, LIns *base);
            void asm_store64(LIns *val, int d, LIns *base);
   void asm_restore(LInsp, Reservation*, Register);
   void asm_load(int d, Register r);
   void asm_spilli(LInsp i, Reservation *resv, bool pop);
   void asm_spill(Register rr, int d, bool pop, bool quad);
   void asm_load64(LInsp i);

            void asm_ret(LInsp p);
   void asm_pusharg(LInsp p);
   void asm_quad(LInsp i);
   void asm_loop(LInsp i, NInsList& loopJumps);
   void asm_fcond(LInsp i);
   void asm_cond(LInsp i);
   void asm_arith(LInsp i);
   void asm_neg_not(LInsp i);
   void asm_ld(LInsp i);
   void asm_cmov(LInsp i);
   void asm_param(LInsp i);
   void asm_int(LInsp i);
   void asm_short(LInsp i);
   void asm_qlo(LInsp i);
   void asm_qhi(LInsp i);
   void asm_fneg(LInsp ins);
   void asm_fop(LInsp ins);
   void asm_i2f(LInsp ins);
   void asm_u2f(LInsp ins);
            void asm_promote(LIns *ins);
   Register asm_prep_fcall(Reservation *rR, LInsp ins);
   void asm_nongp_copy(Register r, Register s);
   void asm_call(LInsp);
            void asm_arg(ArgSize, LInsp, Register);
   Register asm_binop_rhs_reg(LInsp ins);

   NIns* asm_branch(bool branchOnFalse, LInsp cond, NIns* targ, bool isfar);
   void asm_switch(LIns* ins, NIns* target);
   void emitJumpTable(SwitchInfo* si, NIns* target);
            void assignSavedRegs();

            void assignSavedParams();
            void reserveSavedRegs();
            void assignParamRegs();
            void handleLoopCarriedExprs();


   enum
   {
    PAGE_READ = 0x0,
    PAGE_WRITE = 0x01,
    PAGE_EXEC = 0x02
   };


   void nInit(AvmCore *);
   Register nRegisterAllocFromSet(RegisterMask set);

   void nRegisterResetAll(RegAlloc& a);
   void nMarkExecute(Page* page, int flags);
   void nFrameRestore(RegisterMask rmask);
   NIns* nPatchBranch(NIns* branch, NIns* location);
   void nFragExit(LIns* guard);


        public:
   const static Register savedRegs[NumSavedRegs];
   const static Register argRegs[NumArgRegs], retRegs[1]; void underrunProtect(long bytes); void nativePageReset(); void nativePageSetup(); void asm_qbinop(LIns*); void MR(Register, Register); void JMP(NIns*); void emit(uint64_t op); void emit8(uint64_t op, int64_t val); void emit32(uint64_t op, int64_t val); void emitrr(uint64_t op, Register r, Register b); void emitrr8(uint64_t op, Register r, Register b); void emitr(uint64_t op, Register b) { emitrr(op, (Register)0, b); } void emitr8(uint64_t op, Register b) { emitrr8(op, (Register)0, b); } void emitprr(uint64_t op, Register r, Register b); void emitrm(uint64_t op, Register r, int32_t d, Register b); void emitprm(uint64_t op, Register r, int32_t d, Register b); void emitrr_imm(uint64_t op, Register r, Register b, int32_t imm); void emitr_imm(uint64_t op, Register r, int32_t imm) { emitrr_imm(op, (Register)0, r, imm); } void emitr_imm8(uint64_t op, Register b, int32_t imm8); void emit_int(Register r, int32_t v); void emit_quad(Register r, uint64_t v); void asm_regarg(ArgSize, LIns*, Register); void asm_stkarg(ArgSize, LIns*, int); void asm_shift(LIns*); void asm_shift_imm(LIns*); void asm_arith_imm(LIns*); void regalloc_unary(LIns *ins, RegisterMask allow, Register &rr, Register &ra); void regalloc_binary(LIns *ins, RegisterMask allow, Register &rr, Register &ra, Register &rb); void regalloc_load(LIns *ins, Register &rr, int32_t &d, Register &rb); void dis(NIns *p, int bytes); void asm_cmp_imm(LIns*); void fcmp(LIns*, LIns*); NIns* asm_fbranch(bool, LIns*, NIns*); int max_stk_used;

  private:
   int32_t _fpuStkDepth;
   int32_t _sv_fpuStkDepth;


   inline void fpu_push() {
    ++_fpuStkDepth; do { if (!(_fpuStkDepth<=0)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "_fpuStkDepth<=0", "./nanojit/Assembler.h", 369); NanoAssertFail(); }; } while (0);
   }
   inline void fpu_pop() {
    --_fpuStkDepth; do { if (!(_fpuStkDepth<=0)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "_fpuStkDepth<=0", "./nanojit/Assembler.h", 372); NanoAssertFail(); }; } while (0);
   }






   avmplus::Config &config;
 };

 inline int32_t disp(Reservation* r)
 {
  return -(int32_t)sizeof(void *) * int32_t(r->arIndex) + NJ_STACK_OFFSET;
 }
}
# 259 "./nanojit/nanojit.h" 2
# 1 "./nanojit/TraceTreeDrawer.h" 1
# 40 "./nanojit/TraceTreeDrawer.h"
# 1 "./dist/include/system_wrappers_js/stdio.h" 1
       
# 2 "./dist/include/system_wrappers_js/stdio.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 41 "./nanojit/TraceTreeDrawer.h" 2

namespace nanojit {
# 86 "./nanojit/TraceTreeDrawer.h"
}
# 260 "./nanojit/nanojit.h" 2
# 41 "./nanojit/NativeAMD64.cpp" 2



# 1 "./nanojit/../vprof/vprof.h" 1
# 100 "./nanojit/../vprof/vprof.h"
# 1 "./dist/include/system_wrappers_js/inttypes.h" 1
       
# 2 "./dist/include/system_wrappers_js/inttypes.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/include/inttypes.h" 1 3 4
# 26 "/usr/include/inttypes.h" 3 4
# 1 "./dist/include/system_wrappers_js/features.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/features.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 27 "/usr/include/inttypes.h" 2 3 4

# 1 "./dist/include/system_wrappers_js/stdint.h" 1 3 4
       
# 2 "./dist/include/system_wrappers_js/stdint.h" 3
#pragma GCC visibility push(default)

#pragma GCC visibility pop
# 29 "/usr/include/inttypes.h" 2 3 4
# 274 "/usr/include/inttypes.h" 3 4
extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 298 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (__const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (__const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();
# 442 "/usr/include/inttypes.h" 3 4
}
# 4 "./dist/include/system_wrappers_js/inttypes.h" 2 3
#pragma GCC visibility pop
# 101 "./nanojit/../vprof/vprof.h" 2
# 111 "./nanojit/../vprof/vprof.h"
extern "C" {


int profileValue (void** id, char* file, int line, int64_t value, ...);
int _profileEntryValue (void* id, int64_t value);
int histValue(void** id, char* file, int line, int64_t value, int nbins, ...);
int _histEntryValue (void* id, int64_t value);


}
# 173 "./nanojit/../vprof/vprof.h"
typedef enum {
    LOCK_IS_FREE = 0,
    LOCK_IS_TAKEN = 1
};

extern

"C"

long _InterlockedCompareExchange (
   long volatile * Destination,
   long Exchange,
   long Comperand
);

typedef struct hist hist;

typedef struct hist {
    int nbins;
    int64_t* lb;
    int64_t* count;
} *hist_t;

typedef struct entry entry;

typedef struct entry {
    long lock;
    char* file;
    int line;
    int64_t value;
    int64_t count;
    int64_t sum;
    int64_t min;
    int64_t max;
    void (*func)(void*);
    hist* h;

    entry* next;


    void* genptr;
    int ivar[4];
    int64_t __attribute__ ((aligned (8))) i64var[4];
    double __attribute__ ((aligned (8))) dvar[4];


    char pad[128];
} *entry_t;
# 45 "./nanojit/NativeAMD64.cpp" 2
# 72 "./nanojit/NativeAMD64.cpp"
namespace nanojit
{
    const Register Assembler::retRegs[] = { RAX };




    const Register Assembler::argRegs[] = { RDI, RSI, RDX, RCX, R8, R9 };
    const Register Assembler::savedRegs[] = { RBX, R12, R13, R14, R15 };


    const char *regNames[] = {
        "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
        "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
        "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7",
        "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15"
    };




    static void todo(const char *s) {
        outputForEOL("%s",s);

        do { if (!(false)) { fprintf(stderr, "Assertion failed: " "%s" ": " "%s (%s:%d)\n", s, "false", "./nanojit/NativeAMD64.cpp", 96); NanoAssertFail(); }; } while (0);
    }
# 109 "./nanojit/NativeAMD64.cpp"
    const RegisterMask BaseRegs = GpRegs & ~rmask(R12);

    static inline int oplen(uint64_t op) {
        return op & 255;
    }


    static inline uint64_t rexrb(uint64_t op, Register r, Register b) {
        int shift = 64 - 8*oplen(op);
        uint64_t rex = ((op >> shift) & 255) | ((r&8)>>1) | ((b&8)>>3);
        return rex != 0x40 ? op | rex << shift : op - 1;
    }



    static inline uint64_t rexrb8(uint64_t op, Register r, Register b) {
        int shift = 64 - 8*oplen(op);
        uint64_t rex = ((op >> shift) & 255) | ((r&8)>>1) | ((b&8)>>3);
        return ((rex | (b & ~3)) != 0x40) ? (op | (rex << shift)) : op - 1;
    }



    static inline uint64_t rexprb(uint64_t op, Register r, Register b) {
        int shift = 64 - 8*oplen(op) + 8;
        uint64_t rex = ((op >> shift) & 255) | ((r&8)>>1) | ((b&8)>>3);

        return rex != 0x40 ? op | rex << shift :
            ((op & ~(255LL<<shift)) | (op>>(shift-8)&255) << shift) - 1;
    }


    static inline uint64_t mod_rr(uint64_t op, Register r, Register b) {
        return op | uint64_t((r&7)<<3 | (b&7))<<56;
    }

    static inline uint64_t mod_disp32(uint64_t op, Register r, Register b, int32_t d) {
        do { if (!(IsGpReg(r) && IsGpReg(b))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(r) && IsGpReg(b)", "./nanojit/NativeAMD64.cpp", 146); NanoAssertFail(); }; } while (0);
        do { if (!((b & 7) != 4)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "(b & 7) != 4", "./nanojit/NativeAMD64.cpp", 147); NanoAssertFail(); }; } while (0);
        if (( int32_t(d) == int8_t(d) )) {

            do { if (!((((op>>24)&255)>>6) == 2)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "(((op>>24)&255)>>6) == 2", "./nanojit/NativeAMD64.cpp", 150); NanoAssertFail(); }; } while (0);
            int len = oplen(op);
            op = (op & ~0xff000000LL) | (0x40 | (r&7)<<3 | (b&7))<<24;
            return op<<24 | int64_t(d)<<56 | (len-3);
        } else {

            return op | int64_t(d)<<32 | uint64_t((r&7)<<3 | (b&7))<<24;
        }
    }


    void Assembler::dis(NIns *p, int bytes) {
        char b[32], *s = b;
        *s++ = ' ';
        for (NIns *end = p + bytes; p < end; p++) {
            sprintf(s, "%02x ", *p);
            s += 3;
        }
        *s = 0;
        do { (_stats.native+=(int32_t)(1)); if ((_verbose)) { outline[0]='\0'; if (outputAddr) sprintf(outline, "  %10p  ",_nIns); else sprintf(outline, "              "); sprintf(&outline[14],"%s", b); Assembler::outputAlign(outline, 45); RegAlloc::formatRegisters(_allocator, outline, _thisfrag); Assembler::output_asm(outline); outputAddr=false; } } while (0);
    }


    void Assembler::emit(uint64_t op) {
        int len = oplen(op);



        underrunProtect(8);
        ((int64_t*)_nIns)[-1] = op;
        _nIns -= len;
        { static void* id = 0; (id != 0) ? _profileEntryValue (id, (int64_t) (len)) : profileValue (&id, (char*) ("x64-bytes"), -1, (int64_t) (len), __null) ; };
        if (_verbose) dis(_nIns, len);
    }

    void Assembler::emit8(uint64_t op, int64_t v) {
        do { if (!(( int32_t(v) == int8_t(v) ))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "( int32_t(v) == int8_t(v) )", "./nanojit/NativeAMD64.cpp", 186); NanoAssertFail(); }; } while (0);
        emit(op | uint64_t(v)<<56);
    }

    void Assembler::emit32(uint64_t op, int64_t v) {
        do { if (!(isS32(v))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "isS32(v)", "./nanojit/NativeAMD64.cpp", 191); NanoAssertFail(); }; } while (0);
        emit(op | uint64_t(uint32_t(v))<<32);
    }


    void Assembler::emitrr(uint64_t op, Register r, Register b) {
        emit(rexrb(mod_rr(op, r, b), r, b));
    }


    void Assembler::emitrr8(uint64_t op, Register r, Register b) {
        emit(rexrb8(mod_rr(op, r, b), r, b));
    }


    void Assembler::emitprr(uint64_t op, Register r, Register b) {
        emit(rexprb(mod_rr(op, r, b), r, b));
    }


    void Assembler::emitrm(uint64_t op, Register r, int32_t d, Register b) {
        emit(rexrb(mod_disp32(op, r, b, d), r, b));
    }


    void Assembler::emitprm(uint64_t op, Register r, int32_t d, Register b) {
        if (( int32_t(d) == int8_t(d) )) {
            do { if (!(((op>>56)&0xC0) == 0x80)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "((op>>56)&0xC0) == 0x80", "./nanojit/NativeAMD64.cpp", 218); NanoAssertFail(); }; } while (0);
            underrunProtect(1+8);
            *(--_nIns) = (NIns) d;
            { static void* id = 0; (id != 0) ? _profileEntryValue (id, (int64_t) (1)) : profileValue (&id, (char*) ("x64-bytes"), -1, (int64_t) (1), __null) ; };
            op ^= 0xC000000000000000LL;
        } else {
            underrunProtect(4+8);
            *((int32_t*)(_nIns -= 4)) = d;
            { static void* id = 0; (id != 0) ? _profileEntryValue (id, (int64_t) (4)) : profileValue (&id, (char*) ("x64-bytes"), -1, (int64_t) (4), __null) ; };
        }
        emitprr(op, r, b);
    }

    void Assembler::emitrr_imm(uint64_t op, Register r, Register b, int32_t imm) {
        do { if (!(IsGpReg(r) && IsGpReg(b))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(r) && IsGpReg(b)", "./nanojit/NativeAMD64.cpp", 232); NanoAssertFail(); }; } while (0);
        underrunProtect(4+8);
        *((int32_t*)(_nIns -= 4)) = imm;
        { static void* id = 0; (id != 0) ? _profileEntryValue (id, (int64_t) (4)) : profileValue (&id, (char*) ("x86-bytes"), -1, (int64_t) (4), __null) ; };
        emitrr(op, r, b);
    }


    void Assembler::emitr_imm8(uint64_t op, Register b, int32_t imm8) {
        do { if (!(IsGpReg(b) && ( int32_t(imm8) == int8_t(imm8) ))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(b) && ( int32_t(imm8) == int8_t(imm8) )", "./nanojit/NativeAMD64.cpp", 241); NanoAssertFail(); }; } while (0);
        op |= uint64_t(imm8)<<56 | uint64_t(b&7)<<48;
        emit(rexrb(op, (Register)0, b));
    }

    void Assembler::MR(Register d, Register s) {
        do { if (!(IsGpReg(d) && IsGpReg(s))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(d) && IsGpReg(s)", "./nanojit/NativeAMD64.cpp", 247); NanoAssertFail(); }; } while (0);
        emitrr(X64_movqr, d, s);
    }

    void Assembler::JMP(NIns *target) {
        if (!target || isS32(target - _nIns)) {
            underrunProtect(8);
            if (target && ( int32_t(target - _nIns) == int8_t(target - _nIns) )) {
                emit8(X64_jmp8, target - _nIns);
            } else {
                emit32(X64_jmp, target ? target - _nIns : 0);
            }
        } else {
            todo("jmp64");
        }
    }


    void Assembler::regalloc_binary(LIns *ins, RegisterMask allow, Register &rr, Register &ra, Register &rb) {
        LIns *a = ins->oprnd1();
        LIns *b = ins->oprnd2();
        if (a != b) {
            rb = findRegFor(b, allow);
            allow &= ~rmask(rb);
        }
        rr = prepResultReg(ins, allow);
        Reservation* rA = getresv(a);

        if (rA == 0 || (ra = rA->reg) == UnknownReg) {
            ra = findSpecificRegFor(a, rr);
        } else {

        }
        if (a == b) {
            rb = ra;
        }
    }

    void Assembler::asm_qbinop(LIns *ins) {
        asm_arith(ins);
    }

    void Assembler::asm_shift(LIns *ins) {

        LIns *b = ins->oprnd2();
        if (b->isconst()) {
            asm_shift_imm(ins);
            return;
        }
        Register rr, ra;
        if (b != ins->oprnd1()) {
            findSpecificRegFor(b, RCX);
            regalloc_unary(ins, GpRegs & ~rmask(RCX), rr, ra);
        } else {

            regalloc_unary(ins, rmask(RCX), rr, ra);
        }
        X64Opcode xop;
        switch (ins->opcode()) {
        default:
            todo("asm_shift");
        case LIR_qursh: xop = X64_shrq; break;
        case LIR_qirsh: xop = X64_sarq; break;
        case LIR_qilsh: xop = X64_shlq; break;
        case LIR_ush: xop = X64_shr; break;
        case LIR_rsh: xop = X64_sar; break;
        case LIR_lsh: xop = X64_shl; break;
        }
        emitr(xop, rr);
        if (rr != ra)
            MR(rr, ra);
    }

    void Assembler::asm_shift_imm(LIns *ins) {
        Register rr, ra;
        regalloc_unary(ins, GpRegs, rr, ra);
        X64Opcode xop;
        switch (ins->opcode()) {
        default: todo("shiftimm");
        case LIR_qursh: xop = X64_shrqi; break;
        case LIR_qirsh: xop = X64_sarqi; break;
        case LIR_qilsh: xop = X64_shlqi; break;
        case LIR_ush: xop = X64_shri; break;
        case LIR_rsh: xop = X64_sari; break;
        case LIR_lsh: xop = X64_shli; break;
        }
        int shift = ins->oprnd2()->constval() & 255;
        emit8(rexrb(xop | uint64_t(rr&7)<<48, (Register)0, rr), shift);
        if (rr != ra)
            MR(rr, ra);
    }

    static bool isImm32(LIns *ins) {
        return ins->isconst() || (ins->isconstq() && isS32(ins->constvalq()));
    }
    static int32_t getImm32(LIns *ins) {
        return ins->isconst() ? ins->constval() : int32_t(ins->constvalq());
    }


    void Assembler::asm_arith_imm(LIns *ins) {
        LIns *b = ins->oprnd2();
        int32_t imm = getImm32(b);
        LOpcode op = ins->opcode();
        Register rr, ra;
        if (op == LIR_mul) {

            rr = prepResultReg(ins, GpRegs);
            LIns *a = ins->oprnd1();
            ra = findRegFor(a, GpRegs);
            emitrr_imm(X64_imuli, rr, ra, imm);
            return;
        }
        regalloc_unary(ins, GpRegs, rr, ra);
        X64Opcode xop;
        if (( int32_t(imm) == int8_t(imm) )) {
            switch (ins->opcode()) {
            default: todo("arith_imm8");
            case LIR_iaddp:
            case LIR_add: xop = X64_addlr8; break;
            case LIR_and: xop = X64_andlr8; break;
            case LIR_or: xop = X64_orlr8; break;
            case LIR_sub: xop = X64_sublr8; break;
            case LIR_xor: xop = X64_xorlr8; break;
            case LIR_qiadd:
            case LIR_qaddp: xop = X64_addqr8; break;
            case LIR_qiand: xop = X64_andqr8; break;
            case LIR_qior: xop = X64_orqr8; break;
            case LIR_qxor: xop = X64_xorqr8; break;
            }
            emitr_imm8(xop, rr, imm);
        } else {
            switch (ins->opcode()) {
            default: todo("arith_imm");
            case LIR_iaddp:
            case LIR_add: xop = X64_addlri; break;
            case LIR_and: xop = X64_andlri; break;
            case LIR_or: xop = X64_orlri; break;
            case LIR_sub: xop = X64_sublri; break;
            case LIR_xor: xop = X64_xorlri; break;
            case LIR_qiadd:
            case LIR_qaddp: xop = X64_addqri; break;
            case LIR_qiand: xop = X64_andqri; break;
            case LIR_qior: xop = X64_orqri; break;
            case LIR_qxor: xop = X64_xorqri; break;
            }
            emitr_imm(xop, rr, imm);
        }
  if (rr != ra)
   MR(rr, ra);
    }


    void Assembler::asm_arith(LIns *ins) {
        Register rr, ra, rb;
        LOpcode op = ins->opcode();
        if ((op & ~LIR64) >= LIR_lsh && (op & ~LIR64) <= LIR_ush) {
            asm_shift(ins);
            return;
        }
        LIns *b = ins->oprnd2();
        if (isImm32(b)) {
            asm_arith_imm(ins);
            return;
        }
        regalloc_binary(ins, GpRegs, rr, ra, rb);
        X64Opcode xop;
        switch (ins->opcode()) {
        default:
            todo("asm_arith");
        case LIR_or:
            xop = X64_orlrr;
            break;
        case LIR_sub:
            xop = X64_subrr;
            break;
        case LIR_iaddp:
        case LIR_add:
            xop = X64_addrr;
            break;
        case LIR_and:
            xop = X64_andrr;
            break;
        case LIR_xor:
            xop = X64_xorrr;
            break;
        case LIR_mul:
            xop = X64_imul;
            break;
        case LIR_qxor:
            xop = X64_xorqrr;
            break;
        case LIR_qior:
            xop = X64_orqrr;
            break;
        case LIR_qiand:
            xop = X64_andqrr;
            break;
        case LIR_qiadd:
        case LIR_qaddp:
            xop = X64_addqrr;
            break;
        }
        emitrr(xop, rr, rb);
        if (rr != ra)
            MR(rr,ra);
    }


    void Assembler::asm_fop(LIns *ins) {
        Register rr, ra, rb;
        regalloc_binary(ins, FpRegs, rr, ra, rb);
        X64Opcode xop;
        switch (ins->opcode()) {
        default:
            todo("asm_fop");
        case LIR_fdiv:
            xop = X64_divsd;
            break;
        case LIR_fmul:
            xop = X64_mulsd;
            break;
        case LIR_fadd:
            xop = X64_addsd;
            break;
        case LIR_fsub:
            xop = X64_subsd;
            break;
        }
        emitprr(xop, rr, rb);
        if (rr != ra) {
            asm_nongp_copy(rr, ra);
        }
    }

    void Assembler::asm_neg_not(LIns *ins) {
        Register rr, ra;
        regalloc_unary(ins, GpRegs, rr, ra);
        do { if (!(IsGpReg(ra))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(ra)", "./nanojit/NativeAMD64.cpp", 485); NanoAssertFail(); }; } while (0);
        X64Opcode xop;
        if (ins->isop(LIR_not)) {
            xop = X64_not;
        } else {
            xop = X64_neg;
        }
        emitr(xop, rr);
  if (rr != ra)
   MR(rr, ra);
    }

    void Assembler::asm_call(LIns *ins) {
        const CallInfo *call = ins->callInfo();
        ArgSize sizes[MAXARGS];
        int argc = call->get_sizes(sizes);

        bool indirect = call->isIndirect();
        if (!indirect) {
            if (_verbose) outputf("        %p:", _nIns);


            NIns *target = (NIns*)call->_address;

            underrunProtect(8);
            if (isS32(target - _nIns)) {
                emit32(X64_call, target - _nIns);
            } else {

                emit(X64_callrax);
                emit_quad(RAX, (uint64_t)target);
            }
        } else {



            asm_regarg(ARGSIZE_P, ins->arg(--argc), RAX);
            emit(X64_callrax);
        }




        int stk_used = 0;
        Register fr = XMM0;

        int arg_index = 0;
        for (int i = 0; i < argc; i++) {
            int j = argc - i - 1;
            ArgSize sz = sizes[j];
            LIns* arg = ins->arg(j);
            if ((sz & ARGSIZE_MASK_INT) && arg_index < NumArgRegs) {

                asm_regarg(sz, arg, argRegs[arg_index]);
                arg_index++;
            }







            else if (sz == ARGSIZE_F && fr < XMM8) {

                asm_regarg(sz, arg, fr);
                fr = nextreg(fr);
            }

            else {
                asm_stkarg(sz, arg, stk_used);
                stk_used += sizeof(void*);
            }
        }

        if (stk_used > max_stk_used)
            max_stk_used = stk_used;
    }

    void Assembler::asm_regarg(ArgSize sz, LIns *p, Register r) {
        if (sz == ARGSIZE_I) {
            do { if (!(!p->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "!p->isQuad()", "./nanojit/NativeAMD64.cpp", 566); NanoAssertFail(); }; } while (0);
            if (p->isconst()) {
                emit_quad(r, int64_t(p->constval()));
                return;
            }

            emitrr(X64_movsxdr, r, r);
        } else if (sz == ARGSIZE_U) {
            do { if (!(!p->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "!p->isQuad()", "./nanojit/NativeAMD64.cpp", 574); NanoAssertFail(); }; } while (0);
            if (p->isconst()) {
                emit_quad(r, uint64_t(uint32_t(p->constval())));
                return;
            }

            emitrr(X64_movlr, r, r);
        }







        findSpecificRegFor(p, r);
    }

    void Assembler::asm_stkarg(ArgSize sz, LIns *p, int stk_off) {
        do { if (!(( int32_t(stk_off) == int8_t(stk_off) ))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "( int32_t(stk_off) == int8_t(stk_off) )", "./nanojit/NativeAMD64.cpp", 593); NanoAssertFail(); }; } while (0);
        if (sz & ARGSIZE_MASK_INT) {
            Register r = findRegFor(p, GpRegs);
            uint64_t xop = X64_movqspr | uint64_t(stk_off) << 56;
            xop |= uint64_t((r&7)<<3) << 40 | uint64_t((r&8)>>1) << 24;
            emit(xop);
            if (sz == ARGSIZE_I) {

                do { if (!(!p->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "!p->isQuad()", "./nanojit/NativeAMD64.cpp", 601); NanoAssertFail(); }; } while (0);
                emitrr(X64_movsxdr, r, r);
            } else if (sz == ARGSIZE_U) {

                do { if (!(!p->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "!p->isQuad()", "./nanojit/NativeAMD64.cpp", 605); NanoAssertFail(); }; } while (0);
                emitrr(X64_movlr, r, r);
            }
        } else {
            todo("asm_stkarg_non_int");
        }
    }

    void Assembler::asm_promote(LIns *ins) {
        Register rr, ra;
        regalloc_unary(ins, GpRegs, rr, ra);
        do { if (!(IsGpReg(ra))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(ra)", "./nanojit/NativeAMD64.cpp", 616); NanoAssertFail(); }; } while (0);
        if (ins->isop(LIR_u2q)) {
            emitrr(X64_movlr, rr, ra);
        } else {
            do { if (!(ins->isop(LIR_i2q))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "ins->isop(LIR_i2q)", "./nanojit/NativeAMD64.cpp", 620); NanoAssertFail(); }; } while (0);
            emitrr(X64_movsxdr, rr, ra);
        }
    }

    void Assembler::asm_short(LIns *ins) {
        asm_int(ins);
    }





    void Assembler::asm_i2f(LIns *ins) {
        Register r = prepResultReg(ins, FpRegs);
        Register b = findRegFor(ins->oprnd1(), GpRegs);
        emitprr(X64_cvtsi2sd, r, b);
        emitprr(X64_xorps, r, r);
    }

    void Assembler::asm_u2f(LIns *ins) {
        Register r = prepResultReg(ins, FpRegs);
        Register b = findRegFor(ins->oprnd1(), GpRegs);
        do { if (!(!ins->oprnd1()->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "!ins->oprnd1()->isQuad()", "./nanojit/NativeAMD64.cpp", 643); NanoAssertFail(); }; } while (0);

        emitprr(X64_cvtsq2sd, r, b);
        emitprr(X64_xorps, r, r);
        emitrr(X64_movlr, b, b);
    }

    void Assembler::asm_cmov(LIns *ins) {
        LIns* cond = ins->oprnd1();
        do { if (!(cond->isCmp())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "cond->isCmp()", "./nanojit/NativeAMD64.cpp", 652); NanoAssertFail(); }; } while (0);
        LIns* values = ins->oprnd2();
        do { if (!(values->opcode() == LIR_2)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "values->opcode() == LIR_2", "./nanojit/NativeAMD64.cpp", 654); NanoAssertFail(); }; } while (0);
        LIns* iftrue = values->oprnd1();
        LIns* iffalse = values->oprnd2();

        do { if (!((ins->isop(LIR_qcmov) && iftrue->isQuad() && iffalse->isQuad()) || (ins->isop(LIR_cmov) && !iftrue->isQuad() && !iffalse->isQuad()))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "(ins->isop(LIR_qcmov) && iftrue->isQuad() && iffalse->isQuad()) || (ins->isop(LIR_cmov) && !iftrue->isQuad() && !iffalse->isQuad())", "./nanojit/NativeAMD64.cpp", 659); NanoAssertFail(); }; } while (0);




        const Register rr = prepResultReg(ins, GpRegs);
        const Register rf = findRegFor(iffalse, GpRegs & ~rmask(rr));
        X64Opcode xop;
        switch (cond->opcode()) {
            default: todo("asm_cmov");
            case LIR_qeq:
                xop = X64_cmovqne;
                break;
        }
        emitrr(xop, rr, rf);
                                findSpecificRegFor(iftrue, rr);
        asm_cmp(cond);
    }

    NIns* Assembler::asm_branch(bool onFalse, LIns *cond, NIns *target, bool isFar) {
        LOpcode condop = cond->opcode();
        if (condop >= LIR_feq && condop <= LIR_fge)
            return asm_fbranch(onFalse, cond, target);



        underrunProtect(8);
        if (target && ( int32_t(target - _nIns) == int8_t(target - _nIns) )) {
            static const X64Opcode j8[] = {
                X64_je8,
                X64_jl8, X64_jg8, X64_jle8, X64_jge8,
                X64_jb8, X64_ja8, X64_jbe8, X64_jae8
            };
            uint64_t xop = j8[(condop & ~LIR64) - LIR_eq];
            xop ^= onFalse ? (uint64_t)X64_jneg8 : 0;
            emit8(xop, target - _nIns);
        } else {
            static const X64Opcode j32[] = {
                X64_je,
                X64_jl, X64_jg, X64_jle, X64_jge,
                X64_jb, X64_ja, X64_jbe, X64_jae
            };
            uint64_t xop = j32[(condop & ~LIR64) - LIR_eq];
            xop ^= onFalse ? (uint64_t)X64_jneg : 0;
            emit32(xop, target ? target - _nIns : 0);
        }
        NIns *patch = _nIns;
        asm_cmp(cond);
        return patch;
    }

    void Assembler::asm_cmp(LIns *cond) {
        LIns *b = cond->oprnd2();
        if (isImm32(b)) {
            asm_cmp_imm(cond);
            return;
        }
        LIns *a = cond->oprnd1();
        Register ra, rb;
        if (a != b) {
            Reservation *resva, *resvb;
            findRegFor2(GpRegs, a, resva, b, resvb);
            ra = resva->reg;
            rb = resvb->reg;
        } else {

            ra = rb = findRegFor(a, GpRegs);
        }

        LOpcode condop = cond->opcode();
        emitrr(condop & LIR64 ? X64_cmpqr : X64_cmplr, ra, rb);
    }

    void Assembler::asm_cmp_imm(LIns *cond) {
        LIns *a = cond->oprnd1();
        LIns *b = cond->oprnd2();
        Register ra = findRegFor(a, GpRegs);
        int32_t imm = getImm32(b);
        if (( int32_t(imm) == int8_t(imm) )) {
            X64Opcode xop = (cond->opcode() & LIR64) ? X64_cmpqr8 : X64_cmplr8;
            emitr_imm8(xop, ra, imm);
        } else {
            X64Opcode xop = (cond->opcode() & LIR64) ? X64_cmpqri : X64_cmplri;
            emitr_imm(xop, ra, imm);
        }
    }
# 763 "./nanojit/NativeAMD64.cpp"
    NIns* Assembler::asm_fbranch(bool onFalse, LIns *cond, NIns *target) {
        LOpcode condop = cond->opcode();
        NIns *patch;
        LIns *a = cond->oprnd1();
        LIns *b = cond->oprnd2();
        if (condop == LIR_feq) {
            if (onFalse) {

                underrunProtect(16);
                emit32(X64_jp, target ? target - _nIns : 0);
                emit32(X64_jne, target ? target - _nIns : 0);
                patch = _nIns;
            } else {



                underrunProtect(16);
                NIns *skip = _nIns;
                emit32(X64_je, target ? target - _nIns : 0);
                patch = _nIns;
                emit8(X64_jp8, skip - _nIns);
            }
        }
        else {
            if (condop == LIR_flt) {
                condop = LIR_fgt;
                LIns *t = a; a = b; b = t;
            } else if (condop == LIR_fle) {
                condop = LIR_fge;
                LIns *t = a; a = b; b = t;
            }
            X64Opcode xop;
            if (condop == LIR_fgt)
                xop = onFalse ? X64_jbe : X64_ja;
            else
                xop = onFalse ? X64_jb : X64_jae;
            underrunProtect(8);
            emit32(xop, target ? target - _nIns : 0);
            patch = _nIns;
        }
        fcmp(a, b);
        return patch;
    }

    void Assembler::asm_fcond(LIns *ins) {
        LOpcode op = ins->opcode();
        LIns *a = ins->oprnd1();
        LIns *b = ins->oprnd2();
        if (op == LIR_feq) {


            Register r = prepResultReg(ins, 1<<RAX|1<<RCX|1<<RDX|1<<RBX);
            emitrr8(X64_movzx8, r, r);
            emit(X86_and8r | uint64_t(r<<3|(r|4))<<56);
            emit(X86_setnp | uint64_t(r|4)<<56);
            emit(X86_sete | uint64_t(r)<<56);
        } else {
            if (op == LIR_flt) {
                op = LIR_fgt;
                LIns *t = a; a = b; b = t;
            } else if (op == LIR_fle) {
                op = LIR_fge;
                LIns *t = a; a = b; b = t;
            }
            Register r = prepResultReg(ins, GpRegs);
            emitrr8(X64_movzx8, r, r);
            emitr8(op == LIR_fgt ? X64_seta : X64_setae, r);
        }
        fcmp(a, b);
    }

    void Assembler::fcmp(LIns *a, LIns *b) {
        Reservation *resva, *resvb;
        findRegFor2(FpRegs, a, resva, b, resvb);
        emitprr(X64_ucomisd, resva->reg, resvb->reg);
    }

    void Assembler::asm_restore(LIns *ins, Reservation *resv, Register r) {
        (void) r;
        if (ins->isop(LIR_alloc)) {
            int d = disp(resv);
            emitrm(X64_leaqrm, r, d, FP);
        }
        else if (ins->isconst()) {
            if (!resv->arIndex) {
                reserveFree(ins);
            }

            emit_int(r, ins->constval());
        }
        else if (ins->isconstq() && IsGpReg(r)) {
            if (!resv->arIndex) {
                reserveFree(ins);
            }

            emit_quad(r, ins->constvalq());
        }
        else {
            int d = findMemFor(ins);
            if (IsFpReg(r)) {
                do { if (!(ins->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "ins->isQuad()", "./nanojit/NativeAMD64.cpp", 863); NanoAssertFail(); }; } while (0);

                emitprm(X64_movsdrm, r, d, FP);
            } else if (ins->isQuad()) {
                emitrm(X64_movqrm, r, d, FP);
            } else {
                emitrm(X64_movlrm, r, d, FP);
            }
        }
        if (_verbose) outputf("        restore %s",_thisfrag->lirbuf->names->formatRef(ins));



    }

    void Assembler::asm_cond(LIns *ins) {
        LOpcode op = ins->opcode();

        Register r = prepResultReg(ins, GpRegs);

        emitrr8(X64_movzx8, r, r);
        X64Opcode xop;
        switch (op) {
        default:
            todo("cond");
        case LIR_qeq:
        case LIR_eq: xop = X64_sete; break;
        case LIR_qlt:
        case LIR_lt: xop = X64_setl; break;
        case LIR_qle:
        case LIR_le: xop = X64_setle; break;
        case LIR_qgt:
        case LIR_gt: xop = X64_setg; break;
        case LIR_qge:
        case LIR_ge: xop = X64_setge; break;
        case LIR_qult:
        case LIR_ult: xop = X64_setb; break;
        case LIR_qule:
        case LIR_ule: xop = X64_setbe; break;
        case LIR_qugt:
        case LIR_ugt: xop = X64_seta; break;
        case LIR_quge:
        case LIR_uge: xop = X64_setae; break;
        case LIR_ov: xop = X64_seto; break;
        case LIR_cs: xop = X64_setc; break;
        }
        emitr8(xop, r);
        asm_cmp(ins);
    }

    void Assembler::asm_ret(LIns *ins) {
        JMP(_epilogue);
        assignSavedParams();
        LIns *value = ins->oprnd1();
        Register r = ins->isop(LIR_ret) ? RAX : XMM0;
        findSpecificRegFor(value, r);
    }

    void Assembler::asm_nongp_copy(Register d, Register s) {
        if (!IsFpReg(d) && IsFpReg(s)) {

            emitprr(X64_movqrx, s, d);
        } else if (IsFpReg(d) && IsFpReg(s)) {

            emitrr(X64_movapsr, d, s);
        } else {

            emitprr(X64_movqxr, d, s);
        }
    }

    void Assembler::regalloc_load(LIns *ins, Register &rr, int32_t &dr, Register &rb) {
        dr = ins->oprnd2()->constval();
        LIns *base = ins->oprnd1();
        rb = getBaseReg(base, dr, BaseRegs);
        Reservation *resv = getresv(ins);
        if (resv && (rr = resv->reg) != UnknownReg) {

            freeRsrcOf(ins, false);
        } else {

            rr = prepResultReg(ins, GpRegs & ~rmask(rb));
        }
    }

    void Assembler::asm_load64(LIns *ins) {
        Register rr, rb;
        int32_t dr;
        regalloc_load(ins, rr, dr, rb);
        if (IsGpReg(rr)) {

            emitrm(X64_movqrm, rr, dr, rb);
        } else {

            emitprm(X64_movsdrm, rr, dr, rb);
        }
    }

    void Assembler::asm_ld(LIns *ins) {
        do { if (!(!ins->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "!ins->isQuad()", "./nanojit/NativeAMD64.cpp", 962); NanoAssertFail(); }; } while (0);
        Register r, b;
        int32_t d;
        regalloc_load(ins, r, d, b);
        emitrm(X64_movlrm, r, d, b);
    }

    void Assembler::asm_store64(LIns *value, int d, LIns *base) {
        do { if (!(value->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "value->isQuad()", "./nanojit/NativeAMD64.cpp", 970); NanoAssertFail(); }; } while (0);
        Register b = getBaseReg(base, d, BaseRegs);


        Reservation *resv = getresv(value);
        Register r;
        if (!resv || (r = resv->reg) == UnknownReg) {
            r = findRegFor(value, GpRegs & ~rmask(b));
        }

        if (IsGpReg(r)) {

            emitrm(X64_movqmr, r, d, b);
        }
        else {

            emitprm(X64_movsdmr, r, d, b);
        }
    }

    void Assembler::asm_store32(LIns *value, int d, LIns *base) {
        do { if (!(!value->isQuad())) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "!value->isQuad()", "./nanojit/NativeAMD64.cpp", 991); NanoAssertFail(); }; } while (0);
        Register b = getBaseReg(base, d, BaseRegs);
        Register r = findRegFor(value, GpRegs & ~rmask(b));


        emitrm(X64_movlmr, r, d, b);
    }


    void Assembler::emit_int(Register r, int32_t v) {
        do { if (!(IsGpReg(r))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(r)", "./nanojit/NativeAMD64.cpp", 1001); NanoAssertFail(); }; } while (0);
        emitr_imm(X64_movi, r, v);
    }


    void Assembler::emit_quad(Register r, uint64_t v) {
        do { if (!(IsGpReg(r))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(r)", "./nanojit/NativeAMD64.cpp", 1007); NanoAssertFail(); }; } while (0);
        if (isU32(v)) {
            emit_int(r, int32_t(v));
            return;
        }
        if (isS32(v)) {

            emitr_imm(X64_movqi32, r, int32_t(v));
            return;
        }
        underrunProtect(8+8);
        ((uint64_t*)_nIns)[-1] = v;
        _nIns -= 8;
        { static void* id = 0; (id != 0) ? _profileEntryValue (id, (int64_t) (8)) : profileValue (&id, (char*) ("x64-bytes"), -1, (int64_t) (8), __null) ; };
        emitr(X64_movqi, r);
    }

    void Assembler::asm_int(LIns *ins) {
        Register r = prepResultReg(ins, GpRegs);
        int32_t v = ins->constval();
        if (v == 0) {

            emitrr(X64_xorrr, r, r);
            return;
        }
        emit_int(r, v);
    }

    void Assembler::asm_quad(LIns *ins) {
        uint64_t v = ins->constvalq();
        RegisterMask allow = v == 0 ? GpRegs|FpRegs : GpRegs;
        Register r = prepResultReg(ins, allow);
        if (v == 0) {
            if (IsGpReg(r)) {

                emitrr(X64_xorrr, r, r);
            } else {

                emitprr(X64_xorps, r, r);
            }
        } else {
            emit_quad(r, v);
        }
    }

    void Assembler::asm_qjoin(LIns*) {
        todo("asm_qjoin");
    }

    Register Assembler::asm_prep_fcall(Reservation*, LIns *ins) {
        return prepResultReg(ins, rmask(XMM0));
    }

    void Assembler::asm_param(LIns *ins) {
        uint32_t a = ins->imm8();
        uint32_t kind = ins->imm8b();
        if (kind == 0) {


            if (a < 6) {

                prepResultReg(ins, rmask(argRegs[a]));
            } else {


                todo("asm_param_stk");
            }
        }
        else {

            prepResultReg(ins, rmask(savedRegs[a]));
        }
    }
# 1089 "./nanojit/NativeAMD64.cpp"
    void Assembler::regalloc_unary(LIns *ins, RegisterMask allow, Register &rr, Register &ra) {
        LIns *a = ins->oprnd1();
        rr = prepResultReg(ins, allow);
        Reservation* rA = getresv(a);

        if (rA == 0 || (ra = rA->reg) == UnknownReg) {
            ra = findSpecificRegFor(a, rr);
        } else {


        }
    }

    static const int64_t __attribute__ ((aligned (16))) negateMask[] = {0x8000000000000000LL,0};

    void Assembler::asm_fneg(LIns *ins) {
        Register rr, ra;
        if (isS32((uintptr_t)negateMask) || isS32((NIns*)negateMask - _nIns)) {
            regalloc_unary(ins, FpRegs, rr, ra);
            if (isS32((uintptr_t)negateMask)) {

                underrunProtect(4+8);
                *((int32_t*)(_nIns -= 4)) = (int32_t)(uintptr_t)negateMask;
                { static void* id = 0; (id != 0) ? _profileEntryValue (id, (int64_t) (4)) : profileValue (&id, (char*) ("x64-bytes"), -1, (int64_t) (4), __null) ; };
                uint64_t xop = X64_xorpsa | uint64_t((rr&7)<<3)<<48;
                xop = rexrb(xop, rr, (Register)0);
                emit(xop);
            } else {

                underrunProtect(4+8);
                int32_t d = (int32_t) ((NIns*)negateMask - _nIns);
                *((int32_t*)(_nIns -= 4)) = d;
                { static void* id = 0; (id != 0) ? _profileEntryValue (id, (int64_t) (4)) : profileValue (&id, (char*) ("x64-bytes"), -1, (int64_t) (4), __null) ; };
                emitrr(X64_xorpsm, rr, (Register)0);
            }
            if (ra != rr)
                asm_nongp_copy(rr,ra);
        } else {



            rr = prepResultReg(ins, GpRegs);
            ra = findRegFor(ins->oprnd1(), GpRegs & ~rmask(rr));
            emitrr(X64_xorqrr, rr, ra);
            emit_quad(rr, negateMask[0]);
        }
    }

    void Assembler::asm_qhi(LIns*) {
        todo("asm_qhi");
    }

    void Assembler::asm_qlo(LIns *ins) {
        Register rr, ra;
        regalloc_unary(ins, GpRegs, rr, ra);
        do { if (!(IsGpReg(ra))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "IsGpReg(ra)", "./nanojit/NativeAMD64.cpp", 1144); NanoAssertFail(); }; } while (0);
        emitrr(X64_movlr, rr, ra);
    }

    void Assembler::asm_spill(Register rr, int d, bool , bool quad) {
        if (d) {
            if (!IsFpReg(rr)) {
                X64Opcode xop = quad ? X64_movqmr : X64_movlmr;
                emitrm(xop, rr, d, FP);
            } else {

                do { if (!(quad)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "quad", "./nanojit/NativeAMD64.cpp", 1155); NanoAssertFail(); }; } while (0);
                emitprm(X64_movsdmr, rr, d, FP);
            }
        }
    }

    void Assembler::asm_loop(LIns*, NInsList&) {
        todo("asm_loop");
    }

    NIns* Assembler::genPrologue() {

        uint32_t stackNeeded = max_stk_used + _activation.highwatermark * 4;

        uint32_t stackPushed =
            sizeof(void*) +
            sizeof(void*);
        uint32_t aligned = ((((uintptr_t)(stackNeeded + stackPushed))+(((uintptr_t)16)-1))&~(((uintptr_t)16)-1));
        uint32_t amt = aligned - stackPushed;



        if (amt) {
            if (( int32_t(amt) == int8_t(amt) ))
                emitr_imm8(X64_subqr8, RSP, amt);
            else
                emitr_imm(X64_subqri, RSP, amt);
        }

        outputAddr=true; do { (_stats.native+=(int32_t)(1)); if ((_verbose)) { outline[0]='\0'; if (outputAddr) sprintf(outline, "  %10p  ",_nIns); else sprintf(outline, "              "); sprintf(&outline[14],"[patch entry]"); Assembler::outputAlign(outline, 45); RegAlloc::formatRegisters(_allocator, outline, _thisfrag); Assembler::output_asm(outline); outputAddr=false; } } while (0);
        NIns *patchEntry = _nIns;
        MR(FP, RSP);
        emitr(X64_pushr, FP);

        return patchEntry;
    }

    NIns* Assembler::genEpilogue() {



        max_stk_used = 0;
        emit(X64_ret);
        emitr(X64_popr, RBP);
        MR(RSP, RBP);
        return _nIns;
    }

    void Assembler::nRegisterResetAll(RegAlloc &a) {

        a.clear();
        a.used = 0;



        a.free = 0xffffffff & ~(1<<RSP | 1<<RBP);

        a.managed = a.free;
    }

    NIns* Assembler::nPatchBranch(NIns *patch, NIns *target) {
        NIns *next = 0;
        if (patch[0] == 0xE9) {

            next = patch+5;
        } else if (patch[0] == 0x0F && (patch[1] & 0xF0) == 0x80) {

            next = patch+6;
        } else {
            next = 0;
            todo("unknown_patch");
        }
        do { if (!(((int32_t*)next)[-1] == 0)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "((int32_t*)next)[-1] == 0", "./nanojit/NativeAMD64.cpp", 1227); NanoAssertFail(); }; } while (0);
        do { if (!(isS32(target - next))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "isS32(target - next)", "./nanojit/NativeAMD64.cpp", 1228); NanoAssertFail(); }; } while (0);
        ((int32_t*)next)[-1] = int32_t(target - next);
        if (next[0] == 0x0F && next[1] == 0x8A) {


            next += 6;
            do { if (!(((int32_t*)next)[-1] == 0)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "((int32_t*)next)[-1] == 0", "./nanojit/NativeAMD64.cpp", 1234); NanoAssertFail(); }; } while (0);
            do { if (!(isS32(target - next))) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "isS32(target - next)", "./nanojit/NativeAMD64.cpp", 1235); NanoAssertFail(); }; } while (0);
            ((int32_t*)next)[-1] = int32_t(target - next);
        }
        return next;
    }

    Register Assembler::nRegisterAllocFromSet(RegisterMask set) {







        Register r;
        asm("bsf    %1, %%eax\n\t"
            "btr    %%eax, %2\n\t"
            "movl   %%eax, %0\n\t"
            : "=m"(r) : "m"(set), "m"(_allocator.free) : "%eax", "memory");
        (void)set;
        return r;

    }

    void Assembler::nFragExit(LIns*) {
        todo("nFragExit");
    }

    void Assembler::nInit(AvmCore*)
    {}

    void Assembler::underrunProtect(long bytes) {
        do { if (!(bytes<=LARGEST_UNDERRUN_PROT)) { fprintf(stderr, "Assertion failed: " "\"%s\": " "%s (%s:%d)\n", "constant LARGEST_UNDERRUN_PROT is too small", "bytes<=LARGEST_UNDERRUN_PROT", "./nanojit/NativeAMD64.cpp", 1267); NanoAssertFail(); }; } while (0);

        NIns *pc = _nIns;
        Page *p = (Page*)( (int*)((((uintptr_t)(pc-1)))&~(((uintptr_t)NJ_PAGE_SIZE)-1)) );
        NIns *top = (NIns*) &p->code[0];
# 1296 "./nanojit/NativeAMD64.cpp"
        if (pc - bytes < top) {
            if (_verbose) outputf("newpage %p:", pc);
            pageAlloc();


            JMP(pc);
        }

    }

    RegisterMask Assembler::hint(LIns *, RegisterMask allow) {
        return allow;
    }

    void Assembler::nativePageSetup() {
        if (!_nIns) {
            pageAlloc();
           
        }
        if (!_nExitIns) {
            pageAlloc(true);
        }
    }

    void Assembler::nativePageReset()
    {}

    void Assembler::nMarkExecute(Page* page, int flags)
 {
  do { if (!(sizeof(Page) == NJ_PAGE_SIZE)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "sizeof(Page) == NJ_PAGE_SIZE", "./nanojit/NativeAMD64.cpp", 1325); NanoAssertFail(); }; } while (0);
# 1343 "./nanojit/NativeAMD64.cpp"
   static const int kProtFlags[4] =
   {
    0x1,
    0x1|0x2,
    0x1|0x4,
    0x1|0x2|0x4
   };
   int prot = kProtFlags[flags & (PAGE_WRITE|PAGE_EXEC)];
   intptr_t addr = (intptr_t)page;
   addr &= ~((uintptr_t)NJ_PAGE_SIZE - 1);
   do { if (!(addr == (intptr_t)page)) { fprintf(stderr, "Assertion failed: " "%s" "%s (%s:%d)\n", "", "addr == (intptr_t)page", "./nanojit/NativeAMD64.cpp", 1353); NanoAssertFail(); }; } while (0);



   if (mprotect((void *)addr, NJ_PAGE_SIZE, prot) == -1)

   {

    do { if (!(false)) { fprintf(stderr, "Assertion failed: " "\"%s\": " "%s (%s:%d)\n", "FATAL ERROR: mprotect(PROT_EXEC) failed\n", "false", "./nanojit/NativeAMD64.cpp", 1361); NanoAssertFail(); }; } while (0);
                abort();
            }



 }

}
